# JavaScript Core — Конспект для Junior разработчиков

> Подробный конспект по основам JavaScript для подготовки к собеседованиям и изучения языка

---

## Содержание (Table of Contents)

1. [Типы данных в JavaScript](#1-типы-данных-в-javascript)
2. [Примитивные и ссылочные типы](#2-примитивные-и-ссылочные-типы)
3. [Truthy и falsy значения](#3-truthy-и-falsy-значения)
4. [`typeof` и его особенности](#4-typeof-и-его-особенности)
5. [Разница между `null` и `undefined`](#5-разница-между-null-и-undefined)
6. [Как проверить значение на `NaN`](#6-как-проверить-значение-на-nan)
7. [Разница между `isNaN` и `Number.isNaN`](#7-разница-между-isnan-и-numberisnan)
8. [Неявное приведение типов (type coercion)](#8-неявное-приведение-типов-type-coercion)
9. [Разница между `==` и `===`](#9-разница-между--и-)
10. [Странные примеры приведения типов](#10-странные-примеры-приведения-типов)
11. [Отличия `var`, `let` и `const`](#11-отличия-var-let-и-const)
12. [Temporal Dead Zone (TDZ)](#12-temporal-dead-zone-tdz)
13. [Block scope и function scope](#13-block-scope-и-function-scope)
14. [Strict mode в JavaScript](#14-strict-mode-в-javascript)
15. [Что такое hoisting и что именно поднимается](#15-что-такое-hoisting-и-что-именно-поднимается)
16. [Что такое область видимости (scope)](#16-что-такое-область-видимости-scope)
17. [Что такое лексическое окружение](#17-что-такое-лексическое-окружение)
18. [Разница между `function declaration` и `function expression`](#18-разница-между-function-declaration-и-function-expression)
19. [Стрелочные функции и их особенности](#19-стрелочные-функции-и-их-особенности)
20. [Есть ли у стрелочных функций `this`, `arguments`, `prototype`](#20-есть-ли-у-стрелочных-функций-this-arguments-prototype)
21. [Что такое `this` и как он определяется](#21-что-такое-this-и-как-он-определяется)
22. [Потеря контекста `this`](#22-потеря-контекста-this)
23. [`call`, `apply`, `bind` и разница между ними](#23-call-apply-bind-и-разница-между-ними)
24. [Что такое IIFE](#24-что-такое-iife)
25. [Как передаются аргументы в функции (по значению и по ссылке)](#25-как-передаются-аргументы-в-функции-по-значению-и-по-ссылке)
26. [Что такое замыкание](#26-что-такое-замыкание)
27. [Замыкания и приватные переменные](#27-замыкания-и-приватные-переменные)
28. [Замыкания в циклах (`var` vs `let`)](#28-замыкания-в-циклах-var-vs-let)
29. [Изменяемы ли строки в JavaScript](#29-изменяемы-ли-строки-в-javascript)
30. [Что такое объект в JavaScript](#30-что-такое-объект-в-javascript)
31. [Как проверить, что значение — массив](#31-как-проверить-что-значение--массив)
32. [Как проверить наличие свойства в объекте](#32-как-проверить-наличие-свойства-в-объекте)
33. [Разница между `in` и `hasOwnProperty`](#33-разница-между-in-и-hasownproperty)
34. [Итерация по объекту](#34-итерация-по-объекту)
35. [Почему `{}` !== `{}` и как сравниваются объекты](#35-почему----и-как-сравниваются-объекты)
36. [Что такое прототип](#36-что-такое-прототип)
37. [`__proto__`, `[[Prototype]]`, `Object.getPrototypeOf`](#37-__proto__-prototype-objectgetprototypeof)
38. [Цепочка прототипов](#38-цепочка-прототипов)
39. [Что находится в конце цепочки прототипов](#39-что-находится-в-конце-цепочки-прототипов)
40. [Поверхностное и глубокое копирование](#40-поверхностное-и-глубокое-копирование)
41. [Способы копирования объектов](#41-способы-копирования-объектов)
42. [Как сделать глубокую копию объекта](#42-как-сделать-глубокую-копию-объекта)
43. [Ограничения `JSON.parse(JSON.stringify())`](#43-ограничения-jsonparsejsonstringify)
44. [Какие типы данных теряются при `JSON.stringify`](#44-какие-типы-данных-теряются-при-jsonstringify)
45. [Мутация и иммутабельность](#45-мутация-и-иммутабельность)
46. [Методы массивов `map`, `filter`, `reduce`](#46-методы-массивов-map-filter-reduce)
47. [Разница между `map` и `forEach`](#47-разница-между-map-и-foreach)
48. [Методы массива `find`, `some`, `every`](#48-методы-массива-find-some-every)
49. [Мутирующие и немутирующие методы массивов](#49-мутирующие-и-немутирующие-методы-массивов)
50. [`Set`, `Map`, `WeakSet`, `WeakMap`](#50-set-map-weakset-weakmap)
51. [Отличие `Map` от обычного объекта](#51-отличие-map-от-обычного-объекта)
52. [Зачем нужны `WeakMap` и `WeakSet`](#52-зачем-нужны-weakmap-и-weakset)
53. [Что такое Promise](#53-что-такое-promise)
54. [Состояния Promise](#54-состояния-promise)
55. [Цепочки `.then`](#55-цепочки-then)
56. [Способы обработки ошибок в Promise](#56-способы-обработки-ошибок-в-promise)
57. [`Promise.all`, `Promise.race`, `Promise.allSettled`, `Promise.any`](#57-promiseall-promiserace-promiseallsettled-promiseany)
58. [Что происходит, если Promise в `Promise.all` отклоняется](#58-что-происходит-если-promise-в-promiseall-отклоняется)
59. [Что такое `async / await`](#59-что-такое-async--await)
60. [Что возвращает `async` функция](#60-что-возвращает-async-функция)
61. [Можно ли использовать `await` вне `async`](#61-можно-ли-использовать-await-вне-async)
62. [Что такое Event Loop и зачем он нужен](#62-что-такое-event-loop-и-зачем-он-нужен)
63. [Call Stack](#63-call-stack)
64. [Microtasks и Macrotasks](#64-microtasks-и-macrotasks)
65. [Порядок выполнения `async / await`](#65-порядок-выполнения-async--await)
66. [Когда реально выполняется `setTimeout`](#66-когда-реально-выполняется-settimeout)
67. [Порядок выполнения `Promise`, `setTimeout`, `async / await`](#67-порядок-выполнения-promise-settimeout-async--await)
68. [Как работает `try / catch / finally`](#68-как-работает-try--catch--finally)
69. [Как ловить ошибки в `async / await`](#69-как-ловить-ошибки-в-async--await)
70. [Почему `try/catch` не ловит ошибку в `setTimeout`](#70-почему-trycatch-не-ловит-ошибку-в-settimeout)
71. [Ключевые отличия ES5 и ES6+](#71-ключевые-отличия-es5-и-es6)

---

## 1. Типы данных в JavaScript

В JavaScript есть **8 основных типов данных**: 7 примитивных и 1 ссылочный.

### Примитивные типы (7 штук)

Примитивные типы — это простые значения, которые хранятся **непосредственно в переменной**.

1. **`string`** — строки текста
   ```js
   "Привет"
   'Мир'
   `Шаблонная строка`
   ```

2. **`number`** — числа (включая целые, дробные, `Infinity`, `-Infinity`, `NaN`)
   ```js
   42
   3.14
   Infinity
   -Infinity
   NaN
   ```

3. **`boolean`** — логические значения
   ```js
   true
   false
   ```

4. **`null`** — специальное значение, означающее "ничего" или "пусто"
   ```js
   null
   ```

5. **`undefined`** — значение, которое означает, что переменная не была инициализирована
   ```js
   undefined
   ```

6. **`symbol`** — уникальный идентификатор (используется редко, обычно для ключей объектов)
   ```js
   Symbol("описание")
   ```

7. **`bigint`** — целые числа произвольной точности (для очень больших чисел)
   ```js
   123n
   9007199254740991n
   ```

### Ссылочный тип (1 штука)

8. **`object`** — объекты, массивы, функции, даты и другие сложные структуры

   ```js
   { name: "Alex" }        // объект
   [1, 2, 3]              // массив
   function() {}          // функция
   new Date()             // дата
   ```

### Важные отличия

**Примитивы:**
- Хранятся **по значению** — при копировании создаётся новая копия
- **Неизменяемы** (immutable) — нельзя изменить значение напрямую
- Сравниваются **по значению**

**Объекты:**
- Хранятся **по ссылке** — при копировании копируется только ссылка
- **Изменяемы** (mutable) — можно изменять свойства
- Сравниваются **по ссылке**

---

## 2. Примитивные и ссылочные типы

Это важное различие, которое влияет на то, как работают переменные в JavaScript.

### Примитивные типы хранятся по значению

Когда вы копируете примитивное значение, создаётся **новая независимая копия**:

```js
let a = 10;
let b = a;  // копируем значение

b = 20;     // изменяем b

console.log(a);  // 10 — a не изменился!
console.log(b);  // 20
```

**Почему так?** Потому что `a` и `b` — это **две разные ячейки памяти** с независимыми значениями.

### Ссылочные типы хранятся по ссылке

Когда вы копируете объект, копируется **только ссылка** на тот же объект в памяти:

```js
let obj1 = { name: "Alex" };
let obj2 = obj1;  // копируем ссылку, а не сам объект!

obj2.name = "Bob";

console.log(obj1.name);  // "Bob" — obj1 тоже изменился!
console.log(obj2.name);  // "Bob"
```

**Почему так?** Потому что `obj1` и `obj2` **указывают на один и тот же объект** в памяти.

### Визуальная аналогия

Представьте:
- **Примитив** — это как **ксерокопия документа**: изменили копию — оригинал не пострадал
- **Объект** — это как **адрес дома**: два человека записали один адрес, пришли к одному дому, отремонтировали его — оба видят изменения

### Как создать независимую копию объекта?

Используйте способы копирования (подробнее в темах про копирование объектов):

```js
let obj1 = { name: "Alex" };
let obj2 = { ...obj1 };  // создаём новый объект

obj2.name = "Bob";
console.log(obj1.name);  // "Alex" — не изменился!
```

---

## 3. Truthy и falsy значения

В JavaScript любое значение в логическом контексте (например, в `if`) преобразуется в `true` или `false`. 

### Falsy значения (преобразуются в `false`)

В JavaScript всего **8 falsy значений**:

```js
false
0
-0
0n          // BigInt zero
""          // пустая строка
null
undefined
NaN
```

Все остальные значения — **truthy** (преобразуются в `true`).

### Truthy значения (преобразуются в `true`)

Это **все значения**, которые не являются falsy. Примеры:

```js
true
1, -1, 3.14
"hello", "0", "false"  // даже строка "false" — truthy!
[]
{}
function() {}
// и всё остальное
```

### Примеры использования

```js
if ("hello") {
  console.log("Выполнится");  // строка — truthy
}

if ("") {
  console.log("Не выполнится");  // пустая строка — falsy
}

if (0) {
  console.log("Не выполнится");  // 0 — falsy
}

if ([]) {
  console.log("Выполнится");  // пустой массив — truthy!
}

if ({}) {
  console.log("Выполнится");  // пустой объект — truthy!
}
```

### ⚠️ Частая ошибка

**Пустые массивы и объекты — truthy!** Это часто путает:

```js
let arr = [];

if (arr) {
  console.log("Массив существует");  // выполнится
}

if (arr.length === 0) {
  console.log("Массив пустой");  // правильная проверка на пустоту
}
```

### Проверка на существование значения

Для проверки, что значение не `null` и не `undefined`, можно использовать просто проверку в `if`:

```js
let value = null;

if (value) {
  console.log("Есть значение");
} else {
  console.log("Нет значения");  // выполнится
}
```

Но будьте осторожны: `0` и `""` тоже дадут `false`!

---

## 4. `typeof` и его особенности

Оператор `typeof` показывает тип значения. Но у него есть несколько **странных особенностей**, которые важно знать.

### Базовое использование

```js
typeof "hello"      // "string"
typeof 42           // "number"
typeof true         // "boolean"
typeof undefined    // "undefined"
typeof Symbol()     // "symbol"
typeof 123n         // "bigint"
typeof {}           // "object"
typeof []           // "object" (странно!)
typeof null         // "object" (баг JavaScript!)
typeof function(){} // "function"
```

### ⚠️ Особенность 1: `typeof null === "object"`

Это **исторический баг** JavaScript, который нельзя исправить из-за обратной совместимости:

```js
typeof null  // "object" (но null не объект!)
```

**Правильная проверка на `null`:**

```js
let value = null;

// Неправильно
if (typeof value === "object") {
  // может быть объект, массив ИЛИ null
}

// Правильно
if (value === null) {
  // точно null
}
```

### ⚠️ Особенность 2: `typeof NaN === "number"`

`NaN` (Not-a-Number) имеет тип `"number"`, хотя это "не число":

```js
typeof NaN  // "number" (странно!)

// Правильная проверка на NaN
Number.isNaN(NaN)        // true
Number.isNaN("abc")      // false
```

### ⚠️ Особенность 3: `typeof [] === "object"`

Массивы тоже считаются объектами:

```js
typeof []  // "object"

// Правильная проверка на массив
Array.isArray([])        // true
Array.isArray({})        // false
```

### ⚠️ Особенность 4: `typeof function(){} === "function"`

Функции считаются отдельным типом, хотя технически это объекты:

```js
typeof function(){}  // "function"
```

### Универсальная проверка типов

Для надёжной проверки типов комбинируйте `typeof` с другими проверками:

```js
function getType(value) {
  if (value === null) return "null";
  if (Array.isArray(value)) return "array";
  return typeof value;
}

getType(null)      // "null"
getType([])        // "array"
getType({})        // "object"
getType("hello")   // "string"
```

---

## 5. Разница между `null` и `undefined`

Это одна из самых частых тем на собеседованиях. Давайте разберёмся, в чём разница.

### `undefined` — значение не задано

`undefined` означает, что переменная **объявлена, но значение не присвоено**:

```js
let a;
console.log(a);  // undefined

let b = undefined;  // можно явно присвоить (но не рекомендуется)
```

**Когда появляется `undefined`:**
- Переменная объявлена, но не инициализирована
- Свойство объекта не существует
- Функция не вернула значение (неявно возвращает `undefined`)
- Параметр функции не передан

### `null` — явное "ничего"

`null` — это **явно заданное пустое значение**. Его присваивает разработчик:

```js
let user = null;  // явно указываем, что пользователя нет
```

**Когда используется `null`:**
- Когда нужно явно показать, что значение отсутствует
- Когда объект был удалён или не найден
- Как результат функции, когда ничего не найдено

### Сравнение

```js
undefined == null   // true (нестрогое сравнение)
undefined === null  // false (строгое сравнение)

typeof undefined  // "undefined"
typeof null       // "object" (баг JavaScript)
```

### Пример из практики

```js
function getUser(id) {
  let users = { 1: "Alex", 2: "Bob" };
  
  if (users[id]) {
    return users[id];
  }
  
  return null;  // явно показываем, что пользователь не найден
}

let user = getUser(999);
console.log(user);  // null

if (user === null) {
  console.log("Пользователь не найден");
}
```

### ⚠️ Частая ошибка

Не путайте отсутствие свойства и `null`:

```js
let obj = { name: null };

console.log(obj.name);      // null
console.log(obj.age);       // undefined (свойства нет)
console.log(obj.name === null);      // true
console.log(obj.age === undefined);  // true
```

### Когда что использовать?

- Используйте `undefined` для значений по умолчанию (параметры функций)
- Используйте `null` когда нужно явно показать "пусто" (например, когда пользователь вышел из системы)

---

## 6. Как проверить значение на `NaN`

`NaN` означает "Not-a-Number" (не число). Это специальное значение типа `number`, которое получается при невозможных математических операциях.

### Почему `NaN === NaN` не работает?

`NaN` **не равен самому себе** — это особенность стандарта IEEE 754:

```js
NaN === NaN  // false (странно, но так задумано!)
NaN == NaN   // false
```

Поэтому обычное сравнение не работает для проверки.

### ✅ Правильный способ: `Number.isNaN()`

**Рекомендуемый способ** — использовать `Number.isNaN()`:

```js
Number.isNaN(NaN)        // true
Number.isNaN(0 / 0)      // true
Number.isNaN("abc" - 1)  // true

Number.isNaN("abc")      // false (строка не NaN)
Number.isNaN(42)         // false
Number.isNaN(undefined)  // false
```

### ❌ Старый способ: `isNaN()` (не используйте!)

Старая функция `isNaN()` **приводит типы** и может давать неожиданные результаты:

```js
isNaN(NaN)       // true ✅
isNaN("abc")     // true ⚠️ (строку приводит к числу, получается NaN)
isNaN(undefined) // true ⚠️
isNaN({})        // true ⚠️

Number.isNaN("abc")     // false ✅ (не приводит типы)
Number.isNaN(undefined) // false ✅
```

### Разница между `isNaN` и `Number.isNaN`

| Значение | `isNaN()` | `Number.isNaN()` |
|----------|-----------|------------------|
| `NaN` | `true` ✅ | `true` ✅ |
| `"abc"` | `true` ⚠️ | `false` ✅ |
| `undefined` | `true` ⚠️ | `false` ✅ |
| `42` | `false` ✅ | `false` ✅ |

**Вывод:** всегда используйте `Number.isNaN()`.

### Альтернативный способ

Можно использовать тот факт, что `NaN` — единственное значение, которое не равно самому себе:

```js
function isNaNValue(value) {
  return value !== value;
}

isNaNValue(NaN)  // true
isNaNValue(42)   // false
```

Но `Number.isNaN()` более читаемый и явный.

### Примеры получения `NaN`

```js
0 / 0              // NaN
"abc" - 1          // NaN
"hello" * 2        // NaN
Math.sqrt(-1)      // NaN
parseInt("xyz")    // NaN
Number("abc")      // NaN
```

---

## 7. Разница между `isNaN` и `Number.isNaN`

Эта тема очень важна, потому что использование неправильной функции может привести к багам.

### `isNaN()` — старый способ с приведением типов

Функция `isNaN()` **сначала пытается преобразовать значение в число**, а потом проверяет, является ли оно `NaN`:

```js
isNaN(NaN)         // true ✅
isNaN("abc")       // true ⚠️ (превращает "abc" в NaN)
isNaN("123")       // false (превращает "123" в 123, это не NaN)
isNaN("")          // false (превращает "" в 0, это не NaN)
isNaN(undefined)   // true ⚠️ (превращает undefined в NaN)
isNaN(null)        // false (превращает null в 0)
isNaN({})          // true ⚠️ (объект не может быть числом)
```

**Проблема:** функция делает **две вещи сразу** — приводит тип И проверяет на `NaN`. Это путает.

### `Number.isNaN()` — современный способ без приведения типов

`Number.isNaN()` проверяет, является ли значение **точно `NaN`**, без приведения типов:

```js
Number.isNaN(NaN)         // true ✅
Number.isNaN("abc")       // false ✅ (это строка, не NaN)
Number.isNaN("123")       // false ✅
Number.isNaN("")          // false ✅
Number.isNaN(undefined)   // false ✅
Number.isNaN(null)        // false ✅
Number.isNaN({})          // false ✅
```

**Преимущество:** функция делает **только одну вещь** — проверяет, является ли значение `NaN`.

### Визуальная аналогия

Представьте проверку возраста:
- **`isNaN()`** — как спрашивать "это не число?" после попытки прочитать число. Если вы передали "abc", она сначала попытается прочитать, не получится, скажет "да, это не число"
- **`Number.isNaN()`** — как спрашивать "это точно значение NaN?" без попыток прочитать. "abc" — это строка, не `NaN`, поэтому ответ "нет"

### ⚠️ Частая ошибка

```js
let userInput = "123abc";

// Неправильно
if (isNaN(userInput)) {
  console.log("Не число");  // может сработать неожиданно
}

// Правильно
if (Number.isNaN(Number(userInput))) {
  console.log("Не число");
}

// Или ещё лучше
if (isNaN(userInput)) {
  console.log("Не число");  // isNaN() здесь уместна, т.к. нужна проверка "можно ли преобразовать в число"
}
```

### Когда что использовать?

- **`Number.isNaN(value)`** — когда нужно проверить, является ли значение **точно `NaN`**
- **`isNaN(value)`** — когда нужно проверить, **можно ли преобразовать значение в число** (но лучше использовать `Number.isNaN(Number(value))` или `isNaN(value)` явно)

**Рекомендация:** в современном коде используйте `Number.isNaN()`.

---

## 8. Неявное приведение типов (type coercion)

JavaScript **автоматически преобразует типы** в некоторых ситуациях. Это называется неявным приведением типов (type coercion).

### Когда происходит приведение типов?

Приведение типов происходит, когда операции требуют определённого типа, а получают другой:

1. **Арифметические операции** (кроме `+` со строками)
2. **Операторы сравнения** (`==`, `!=`, `>`, `<` и др.)
3. **Условия** (`if`, `while`, `? :`)
4. **Логические операторы** (`&&`, `||`, `!`)

### Преобразование в число

```js
"5" - 2      // 3 (строка → число)
"5" * 2      // 10
"5" / 2      // 2.5
-"5"         // -5
+"5"         // 5 (унарный плюс преобразует в число)

"abc" - 1    // NaN (нельзя преобразовать в число)
```

### Преобразование в строку

Оператор `+` со строками преобразует всё в строки:

```js
"5" + 2        // "52" (число → строка)
"Hello" + 42   // "Hello42"
5 + "2"        // "52"
"" + true      // "true"
"" + null      // "null"
```

### ⚠️ Особенность оператора `+`

`+` ведёт себя по-разному:
- Если хотя бы один операнд — строка → преобразует всё в строки
- Иначе → преобразует в числа

```js
1 + 2          // 3 (оба числа)
"1" + 2        // "12" (есть строка → строка)
1 + "2"        // "12" (есть строка → строка)
1 + 2 + "3"    // "33" (сначала 1+2=3, потом 3+"3"="33")
"1" + 2 + 3    // "123" (сначала "1"+2="12", потом "12"+3="123")
```

### Преобразование в boolean

В логических контекстах значения преобразуются в `true`/`false` (см. тему про truthy/falsy):

```js
if ("hello") { }        // строка → true
if (0) { }              // 0 → false
if ([]) { }             // массив → true
if ("") { }             // пустая строка → false
```

### Правила преобразования

**В число:**
- `null` → `0`
- `undefined` → `NaN`
- `""` (пустая строка) → `0`
- `"123"` → `123`
- `"abc"` → `NaN`
- `true` → `1`, `false` → `0`
- `[]` → `0` (пустой массив)
- `[5]` → `5` (массив с одним числом)
- `[1,2]` → `NaN`

**В строку:**
- `null` → `"null"`
- `undefined` → `"undefined"`
- `true` → `"true"`
- `[]` → `""` (пустой массив)
- `[1,2]` → `"1,2"`

### ⚠️ Частая ошибка

```js
let input = "5";
let result = input + 1;  // "51" (строка!), а не 6!

// Правильно
let result = Number(input) + 1;  // 6
// или
let result = +input + 1;  // 6
```

### Как избежать проблем?

1. **Используйте строгое сравнение** (`===` вместо `==`)
2. **Явно преобразуйте типы** перед операциями
3. **Используйте `Number()`, `String()`, `Boolean()`** для явного преобразования

```js
// Явное преобразование
Number("5") + 1        // 6
String(5) + "2"        // "52"
Boolean(0)             // false
```

---

## 9. Разница между `==` и `===`

Это одна из самых важных тем. Разница между этими операторами часто вызывает баги.

### `===` (строгое равенство)

`===` сравнивает **и тип, и значение**. Если типы разные — сразу возвращает `false`:

```js
5 === 5        // true
5 === "5"      // false (разные типы)
true === 1     // false
null === undefined  // false
```

### `==` (нестрогое равенство)

`==` **приводит типы** перед сравнением, что может давать неожиданные результаты:

```js
5 == 5         // true
5 == "5"       // true ⚠️ (строка "5" преобразуется в число 5)
true == 1      // true ⚠️ (true преобразуется в 1)
false == 0     // true ⚠️
null == undefined  // true ⚠️ (специальное правило)
"" == 0        // true ⚠️
[] == 0        // true ⚠️ (пустой массив → "" → 0)
```

### Правила преобразования в `==`

1. Если типы одинаковые → сравнивает как `===`
2. `null == undefined` → всегда `true` (и наоборот)
3. Если один операнд — число, другой — строка → строка → число
4. Если один — boolean → boolean → число (`true` → `1`, `false` → `0`)
5. Если один — объект → объект → примитив (через `valueOf()` или `toString()`)

### Примеры странного поведения

```js
[] == 0        // true ([] → "" → 0)
[0] == 0       // true ([0] → "0" → 0)
[1,2] == "1,2" // true

"" == false    // true ("" → 0, false → 0)
"0" == false   // true ("0" → 0, false → 0)

null == undefined  // true
null == 0       // false (null не преобразуется в 0 при ==)
undefined == 0  // false
```

### ⚠️ Частая ошибка

```js
let userInput = "0";

if (userInput == false) {
  console.log("Пусто");  // выполнится! ("0" == false → true)
}

// Правильно
if (userInput === "" || userInput === "0") {
  console.log("Пусто или ноль");
}
```

### Когда использовать что?

**Почти всегда используйте `===`** (строгое сравнение):
- Предсказуемое поведение
- Нет неожиданных преобразований
- Быстрее (не нужно преобразовывать типы)

**`==` используйте только если:**
- Вам действительно нужно сравнение с приведением типов
- Сравниваете `null` и `undefined` (но лучше явно: `value == null`)

### Рекомендации

В современном JavaScript **всегда используйте `===`**:

```js
// Хорошо ✅
if (value === 5) { }
if (value === null || value === undefined) { }
if (value == null) { }  // допустимо (проверяет и null, и undefined)

// Плохо ❌
if (value == 5) { }
```

### Сравнение объектов

**Важно:** `==` и `===` для объектов работают одинаково — сравнивают **ссылки**:

```js
{} === {}        // false (разные объекты)
[] === []        // false (разные массивы)

let obj = {};
obj === obj      // true (один и тот же объект)
```

---

## 10. Странные примеры приведения типов

JavaScript может выдавать очень неожиданные результаты из-за приведения типов. Вот самые известные примеры.

### `[] + {}` и `{} + []`

Результат зависит от контекста:

```js
[] + {}        // "[object Object]"
               // [] → "" → "" + "[object Object]"

{} + []        // 0 (в консоли браузера)
               // {} интерпретируется как пустой блок кода!
               // +[] → +"" → 0

({} + [])      // "[object Object]" (с скобками работает иначе)
```

### `'5' - 1` и `'5' + 1`

```js
'5' - 1        // 4 (строка → число)
'5' + 1        // "51" (число → строка, т.к. + со строками)
```

### Сравнения

```js
[] == 0        // true
               // [] → "" → 0

[] == false    // true
               // [] → "" → 0, false → 0

![] == false   // true
               // ![] → false, false == false

[] == ![]      // true ⚠️
               // [] → "" → 0
               // ![] → false → 0
               // 0 == 0 → true

[] == []       // false (объекты сравниваются по ссылке)
```

### Массивы и числа

```js
[1] + [2]      // "12"
               // [1] → "1", [2] → "2", "1" + "2" → "12"

[1,2] + [3,4]  // "1,23,4"
               // [1,2] → "1,2", [3,4] → "3,4"

[10] - [5]     // 5 (при - массивы → числа)
[10] * [5]     // 50
```

### Логические значения

```js
true + true    // 2 (true → 1)
true + false   // 1
false + false  // 0

true == 1      // true
true === 1     // false
```

### Пустые значения

```js
null + 1       // 1 (null → 0)
undefined + 1  // NaN (undefined → NaN)

null == 0      // false (null не преобразуется в 0 при ==)
undefined == 0 // false

!null          // true
!undefined     // true
```

### Зачем это знать?

Эти примеры показывают, **почему важно:**
1. Использовать строгое сравнение (`===`)
2. Явно преобразовывать типы
3. Понимать, как работает приведение типов

### ⚠️ Практический совет

В реальном коде избегайте таких ситуаций:

```js
// Плохо ❌
if (value == []) { }
let result = input + 5;  // может быть строкой!

// Хорошо ✅
if (Array.isArray(value) && value.length === 0) { }
let result = Number(input) + 5;
```

---

## 11. Отличия `var`, `let` и `const`

Это одна из самых важных тем ES6+. Понимание разницы критично для написания правильного кода.

### `var` — старый способ (не используйте!)

`var` имеет **функциональную область видимости** и **поднимается** (hoisting):

```js
function test() {
  if (true) {
    var x = 10;
  }
  console.log(x);  // 10 (доступна вне блока!)
}

console.log(y);  // undefined (не ошибка!)
var y = 20;
```

**Проблемы `var`:**
- Область видимости — вся функция, а не блок
- Поднимается со значением `undefined`
- Можно переопределять в той же области
- Нет защиты от ошибок

### `let` — современная замена `var`

`let` имеет **блочную область видимости** и находится в TDZ:

```js
function test() {
  if (true) {
    let x = 10;
  }
  console.log(x);  // ReferenceError (x не доступна)
}

console.log(y);  // ReferenceError (нельзя использовать до объявления)
let y = 20;
```

**Преимущества `let`:**
- Область видимости — только блок `{}`
- Нельзя использовать до объявления (TDZ)
- Нельзя переопределять в той же области
- Защита от случайных ошибок

### `const` — для констант

`const` похож на `let`, но **нельзя переопределять**:

```js
const x = 10;
x = 20;  // TypeError (нельзя изменить)

const obj = { name: "Alex" };
obj.name = "Bob";  // ✅ Можно! (изменяется содержимое объекта)
obj = {};          // ❌ TypeError (нельзя переопределить переменную)
```

**Важно:** `const` не делает объект неизменяемым, только переменную!

### Сравнительная таблица

| Особенность | `var` | `let` | `const` |
|-------------|-------|-------|---------|
| Область видимости | функция | блок | блок |
| Поднимается | да (со значением `undefined`) | да (TDZ) | да (TDZ) |
| Можно переопределять | да | нет | нет |
| Можно изменять значение | да | да | нет* |

*Нельзя переопределить переменную, но объект внутри можно изменять

### Примеры

```js
// var — плохо
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);  // 3, 3, 3 (все ссылаются на одну i)
}

// let — хорошо
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);  // 0, 1, 2 (каждая итерация — новая i)
}

// const для массива
const arr = [1, 2, 3];
arr.push(4);      // ✅ Можно
arr = [5, 6];     // ❌ Ошибка
```

### Рекомендации

1. **Всегда используйте `const` по умолчанию**
2. Используйте `let` только если переменная будет изменяться
3. **Никогда не используйте `var`** в новом коде

```js
// Хороший стиль
const name = "Alex";        // не изменяется
let counter = 0;            // будет изменяться
counter++;
```

---

## 12. Temporal Dead Zone (TDZ)

Temporal Dead Zone (TDZ) — это период между началом области видимости и объявлением переменной, когда к переменной **нельзя обратиться**.

### Что такое TDZ?

TDZ существует только для `let` и `const`. Это "мёртвая зона" до объявления переменной:

```js
// TDZ для x начинается здесь (начало области видимости)
console.log(x);  // ReferenceError (в TDZ)
let x = 10;      // TDZ заканчивается здесь
console.log(x);  // 10 (можно использовать)
```

### TDZ для `let`

```js
{
  // TDZ для a начинается
  console.log(a);  // ReferenceError: Cannot access 'a' before initialization
  let a = 5;
  // TDZ заканчивается
  console.log(a);  // 5
}
```

### TDZ для `const`

Работает так же:

```js
{
  console.log(b);  // ReferenceError
  const b = 10;
  console.log(b);  // 10
}
```

### `var` не имеет TDZ

`var` **поднимается** и инициализируется как `undefined`, поэтому TDZ нет:

```js
console.log(c);  // undefined (не ошибка!)
var c = 5;
console.log(c);  // 5
```

### Почему нужна TDZ?

TDZ **предотвращает ошибки**, заставляя объявлять переменные до использования:

```js
// С var — тихая ошибка
console.log(value);  // undefined (непонятно, почему)
var value = 10;

// С let — явная ошибка
console.log(value);  // ReferenceError (сразу видно проблему)
let value = 10;
```

### Примеры TDZ

```js
// TDZ в блоке
if (true) {
  console.log(x);  // ReferenceError
  let x = 1;
}

// TDZ в функции
function test() {
  console.log(y);  // ReferenceError
  let y = 2;
}

// TDZ в цикле
for (let i = 0; i < 3; i++) {
  // каждая итерация имеет свою TDZ для i
}
```

### ⚠️ Частая ошибка

```js
let x = 10;

function test() {
  console.log(x);  // ReferenceError (не глобальная x!)
  let x = 20;      // создаёт локальную x, которая находится в TDZ выше
}
```

Даже если есть глобальная `x`, локальная `x` "затеняет" её и находится в TDZ до объявления.

### TDZ и параметры функций

Параметры функции инициализируются **до** тела функции, поэтому TDZ для них нет:

```js
function test(x = y, y = 2) {
  // ReferenceError (y ещё не инициализирован при инициализации x)
}
```

### Итоги

- TDZ существует только для `let` и `const`
- TDZ начинается в начале области видимости и заканчивается при объявлении
- Обращение к переменной в TDZ вызывает `ReferenceError`
- TDZ помогает находить ошибки на этапе разработки

---

## 13. Block scope и function scope

Область видимости (scope) определяет, **где переменная доступна**. В JavaScript есть несколько типов областей видимости.

### Function scope (область видимости функции)

**Function scope** — переменная доступна **всей функции**, где она объявлена.

`var` имеет function scope:

```js
function test() {
  if (true) {
    var x = 10;  // объявлена в блоке if
  }
  console.log(x);  // 10 ✅ (доступна во всей функции)
}

console.log(x);  // ReferenceError (не доступна вне функции)
```

### Block scope (блочная область видимости)

**Block scope** — переменная доступна только **внутри блока** `{}`, где она объявлена.

`let` и `const` имеют block scope:

```js
function test() {
  if (true) {
    let x = 10;  // объявлена в блоке if
    const y = 20;
  }
  console.log(x);  // ReferenceError ❌ (не доступна вне блока)
  console.log(y);  // ReferenceError ❌
}

{
  let z = 30;
}
console.log(z);  // ReferenceError (не доступна вне блока)
```

### Визуальная аналогия

Представьте комнаты в здании:
- **Function scope** (`var`) — как комната в квартире: доступна везде в квартире (функции)
- **Block scope** (`let`/`const`) — как шкаф в комнате: доступен только в этой комнате (блоке)

### Примеры различий

```js
// var — function scope
function example1() {
  for (var i = 0; i < 3; i++) {
    // что-то делаем
  }
  console.log(i);  // 3 ✅ (доступна после цикла)
}

// let — block scope
function example2() {
  for (let i = 0; i < 3; i++) {
    // что-то делаем
  }
  console.log(i);  // ReferenceError ❌ (не доступна после цикла)
}
```

### Вложенные блоки

В block scope каждый блок создаёт свою область видимости:

```js
let a = 1;  // внешняя область

{
  let a = 2;  // внутренний блок (затеняет внешнюю a)
  console.log(a);  // 2
  
  {
    let a = 3;  // ещё более внутренний блок
    console.log(a);  // 3
  }
  
  console.log(a);  // 2
}

console.log(a);  // 1 (внешняя a)
```

### Почему block scope лучше?

Block scope **ограничивает область видимости**, что:
1. Предотвращает случайное использование переменных
2. Упрощает отладку (меньше конфликтов имён)
3. Позволяет переиспользовать имена в разных блоках

```js
// С var — проблема
function bad() {
  var result = "first";
  
  if (true) {
    var result = "second";  // переопределяет!
  }
  
  console.log(result);  // "second" (неожиданно)
}

// С let — безопасно
function good() {
  let result = "first";
  
  if (true) {
    let result = "second";  // новая переменная в блоке
  }
  
  console.log(result);  // "first" (ожидаемо)
}
```

### Глобальная область видимости

Переменные, объявленные вне функций и блоков, находятся в **глобальной области видимости**:

```js
let global = "доступна везде";

function test() {
  console.log(global);  // "доступна везде"
}
```

### Итоги

- **Function scope** (`var`) — переменная доступна во всей функции
- **Block scope** (`let`/`const`) — переменная доступна только в блоке `{}`
- Block scope безопаснее и предсказуемее
- Используйте `let`/`const` для block scope

---

## 14. Strict mode в JavaScript

Strict mode (строгий режим) делает JavaScript более строгим и помогает находить ошибки.

### Как включить strict mode?

Добавьте `"use strict";` в начало файла или функции:

```js
"use strict";

// весь код в файле в strict mode
```

Или в функции:

```js
function test() {
  "use strict";
  // только эта функция в strict mode
}
```

### Что меняет strict mode?

#### 1. Запрещает использование необъявленных переменных

```js
"use strict";

x = 10;  // ReferenceError (в обычном режиме создалась бы глобальная переменная)
```

#### 2. Меняет поведение `this`

В обычной функции `this` будет `undefined` вместо глобального объекта:

```js
"use strict";

function test() {
  console.log(this);  // undefined (в обычном режиме был бы window/global)
}
```

#### 3. Запрещает дублирование параметров

```js
"use strict";

function test(a, a) {  // SyntaxError
  // ...
}
```

#### 4. Запрещает удаление переменных и функций

```js
"use strict";

let x = 10;
delete x;  // SyntaxError (в обычном режиме просто проигнорировалось бы)
```

#### 5. Запрещает использование некоторых зарезервированных слов

```js
"use strict";

let let = 10;  // SyntaxError
```

#### 6. Делает ошибки из `eval` видимыми

В strict mode ошибки в `eval` не "заглушаются".

### Примеры различий

```js
// Обычный режим
function normal() {
  x = 10;  // создаётся глобальная переменная (плохо!)
  console.log(this);  // window (в браузере)
}

// Strict mode
function strict() {
  "use strict";
  x = 10;  // ReferenceError ✅
  console.log(this);  // undefined ✅
}
```

### ⚠️ Важно

Strict mode **включается для всего скрипта или функции**, где написан `"use strict"`. Его нельзя выключить в середине кода.

### Современные модули

В **ES6 модулях** (`import`/`export`) strict mode **включён по умолчанию**:

```js
// Модуль автоматически в strict mode
export function test() {
  x = 10;  // ReferenceError
}
```

### Рекомендации

1. **Всегда используйте strict mode** в новом коде
2. В модулях он уже включён
3. В обычных скриптах добавляйте `"use strict";` в начало

### Итоги

- Strict mode делает JavaScript строже и безопаснее
- Помогает находить ошибки на раннем этапе
- Включён по умолчанию в ES6 модулях
- Используйте его всегда в новом коде

---

## 15. Что такое hoisting и что именно поднимается

Hoisting (поднятие) — это механизм JavaScript, при котором объявления переменных и функций **"поднимаются"** в начало области видимости.

### Важно понимать

Hoisting — это **концептуальная модель**. На самом деле JavaScript не перемещает код. Но ведёт себя так, будто объявления выполнены первыми.

### Что поднимается?

Разные конструкции поднимаются по-разному:

#### 1. `var` — поднимается со значением `undefined`

```js
console.log(x);  // undefined (не ошибка!)
var x = 10;
console.log(x);  // 10
```

Это работает так, как будто написано:

```js
var x;           // объявление поднято
console.log(x);  // undefined
x = 10;          // присваивание осталось на месте
console.log(x);  // 10
```

#### 2. `let` и `const` — поднимаются, но в TDZ

```js
console.log(y);  // ReferenceError (в TDZ)
let y = 20;
```

Технически `let` тоже поднимается, но находится в Temporal Dead Zone до объявления.

#### 3. `function declaration` — поднимается целиком

```js
test();  // "Работает!" ✅ (можно вызвать до объявления)

function test() {
  console.log("Работает!");
}
```

Функция поднимается **со всем телом**, поэтому её можно вызвать до объявления.

#### 4. `function expression` — НЕ поднимается как функция

```js
test();  // TypeError (test === undefined)

var test = function() {
  console.log("Не работает");
};
```

Здесь поднимается только `var test`, а не функция. Поэтому `test` равен `undefined` до присваивания.

### Сравнительная таблица

| Конструкция | Поднимается? | Инициализация |
|-------------|--------------|---------------|
| `var` | ✅ Да | `undefined` |
| `let` | ✅ Да (TDZ) | Не инициализирована |
| `const` | ✅ Да (TDZ) | Не инициализирована |
| `function declaration` | ✅ Да | Вся функция |
| `function expression` | ❌ Нет | `undefined` (для `var`) |

### Примеры

```js
// var
console.log(a);  // undefined
var a = 1;

// let
console.log(b);  // ReferenceError
let b = 2;

// function declaration
foo();  // "Hello"
function foo() {
  console.log("Hello");
}

// function expression
bar();  // TypeError
var bar = function() {
  console.log("World");
};
```

### Порядок выполнения

При hoisting **функции имеют приоритет** над переменными:

```js
console.log(test);  // function test() { ... } (функция!)

var test = "переменная";

function test() {
  console.log("функция");
}
```

### ⚠️ Частая ошибка

```js
if (true) {
  function test() {
    console.log("A");
  }
} else {
  function test() {
    console.log("B");
  }
}

test();  // Результат зависит от реализации (непредсказуемо!)
```

Function declaration в блоках ведёт себя непредсказуемо. Используйте function expression.

### Рекомендации

1. **Всегда объявляйте переменные до использования**
2. Не полагайтесь на hoisting — это может запутать
3. Используйте `let`/`const` вместо `var` — они безопаснее

### Итоги

- Hoisting — концептуальная модель поведения JavaScript
- `var` поднимается как `undefined`
- `let`/`const` поднимаются, но в TDZ
- Function declaration поднимается целиком
- Function expression не поднимается как функция
- Лучше явно объявлять переменные до использования

---

## 16. Что такое область видимости (scope)

Область видимости (scope) — это **место в коде, где переменная доступна и может быть использована**.

### Типы областей видимости

В JavaScript есть три основных типа областей видимости:

1. **Глобальная область видимости** — переменные, объявленные вне функций и блоков
2. **Функциональная область видимости** — переменные доступны внутри функции (для `var`)
3. **Блочная область видимости** — переменные доступны только внутри блока `{}` (для `let`/`const`)

### Глобальная область видимости

Переменные, объявленные на верхнем уровне, доступны везде:

```js
let global = "доступна везде";

function test1() {
  console.log(global);  // "доступна везде"
}

function test2() {
  console.log(global);  // "доступна везде"
}
```

### Функциональная область видимости

`var` имеет функциональную область видимости — переменная доступна **во всей функции**:

```js
function test() {
  if (true) {
    var x = 10;  // объявлена в блоке
  }
  console.log(x);  // 10 ✅ (доступна во всей функции)
}
```

### Блочная область видимости

`let` и `const` имеют блочную область видимости — переменная доступна **только в блоке**:

```js
function test() {
  if (true) {
    let x = 10;  // объявлена в блоке
  }
  console.log(x);  // ReferenceError ❌ (не доступна вне блока)
}
```

### Вложенность областей видимости

Внутренние области видят внешние переменные, но не наоборот:

```js
let outer = "внешняя";

function test() {
  let middle = "средняя";
  
  if (true) {
    let inner = "внутренняя";
    console.log(outer);   // "внешняя" ✅
    console.log(middle);  // "средняя" ✅
    console.log(inner);   // "внутренняя" ✅
  }
  
  console.log(inner);  // ReferenceError ❌
}
```

### Поиск переменных (scope chain)

Когда JavaScript ищет переменную, он:
1. Сначала смотрит в текущей области видимости
2. Если не находит — поднимается на уровень выше
3. Продолжает до глобальной области
4. Если не находит — `ReferenceError`

```js
let global = "глобальная";

function outer() {
  let outerVar = "внешняя";
  
  function inner() {
    console.log(global);   // "глобальная" (найдена в глобальной области)
    console.log(outerVar); // "внешняя" (найдена во внешней функции)
  }
  
  inner();
}
```

### Затенение (shadowing)

Если во внутренней области объявить переменную с тем же именем, она "затенит" внешнюю:

```js
let x = "внешняя";

function test() {
  let x = "внутренняя";  // затеняет внешнюю x
  console.log(x);        // "внутренняя"
}

console.log(x);  // "внешняя" (не изменилась)
```

### Итоги

- Область видимости определяет доступность переменных
- JavaScript использует лексическую область видимости (определяется местом объявления)
- Внутренние области видят внешние переменные
- `var` имеет функциональную область, `let`/`const` — блочную

---

## 17. Что такое лексическое окружение

Лексическое окружение (Lexical Environment) — это внутренняя структура JavaScript, которая хранит **связь между идентификаторами (именами переменных) и их значениями**.

### Что это такое?

Простыми словами: лексическое окружение — это **"словарь"**, который хранит все переменные и функции в определённой области видимости.

### Структура лексического окружения

Каждое лексическое окружение содержит:

1. **Environment Record** (запись окружения) — объект, хранящий переменные и функции
2. **Ссылка на внешнее окружение** (outer reference) — ссылка на родительское окружение

```js
// Глобальное окружение
let global = "глобальная";  // хранится в глобальном Environment Record

function outer() {
  let outerVar = "внешняя";  // хранится в Environment Record функции outer
  
  function inner() {
    let innerVar = "внутренняя";  // хранится в Environment Record функции inner
    // inner имеет ссылку на окружение outer
    // outer имеет ссылку на глобальное окружение
  }
}
```

### Почему "лексическое"?

**Лексическое** означает, что структура окружения определяется **местом написания кода** (лексически), а не местом вызова.

```js
let x = "глобальная";

function outer() {
  let x = "внешняя";
  
  function inner() {
    console.log(x);  // "внешняя" (берётся из окружения, где функция объявлена)
  }
  
  return inner;
}

let innerFunc = outer();
innerFunc();  // "внешняя" (не "глобальная"!)
```

Функция `inner` "видит" `x` из `outer`, потому что была **объявлена** внутри `outer`, а не потому что была **вызвана** оттуда.

### Как работает поиск переменных?

При обращении к переменной JavaScript:

1. Ищет в текущем Environment Record
2. Если не находит — идёт по ссылке во внешнее окружение
3. Продолжает до глобального окружения
4. Если не находит — `ReferenceError`

Это называется **scope chain** (цепочка областей видимости).

### Пример с замыканием

Лексическое окружение — основа замыканий:

```js
function createCounter() {
  let count = 0;  // хранится в Environment Record createCounter
  
  return function() {
    count++;  // находит count во внешнем окружении (createCounter)
    return count;
  };
}

let counter = createCounter();
counter();  // 1
counter();  // 2
```

Функция "запоминает" окружение, в котором была создана, даже после завершения `createCounter`.

### Визуальная аналогия

Представьте матрёшку:
- Самая внешняя — глобальное окружение
- Внутри неё — окружения функций
- Каждая "знает" о внешней
- Внутренняя может видеть внешние переменные

### Итоги

- Лексическое окружение — внутренняя структура, хранящая переменные
- Определяется местом написания кода (лексически)
- Создаёт цепочку областей видимости (scope chain)
- Основа для работы замыканий

---

## 18. Разница между `function declaration` и `function expression`

В JavaScript функции можно создавать двумя способами, и между ними есть важные отличия.

### Function Declaration (объявление функции)

Function declaration — функция, объявленная как **отдельная инструкция**:

```js
function sayHello() {
  console.log("Hello");
}
```

**Особенности:**
- Поднимается (hoisting) **целиком** — можно вызвать до объявления
- Имеет имя (обязательно)
- Создаётся до выполнения кода

### Function Expression (функциональное выражение)

Function expression — функция, присвоенная **переменной**:

```js
const sayHello = function() {
  console.log("Hello");
};
```

**Особенности:**
- **Не поднимается** как функция (поднимается только переменная)
- Может быть анонимной или именованной
- Создаётся при выполнении кода

### Разница в hoisting

```js
// Function declaration
sayHi();  // "Hi!" ✅ (работает!)

function sayHi() {
  console.log("Hi!");
}

// Function expression
sayBye();  // TypeError ❌ (sayBye === undefined)

const sayBye = function() {
  console.log("Bye!");
};
```

### Когда что использовать?

**Function declaration** — когда функция — основная часть кода:

```js
function calculateTotal(price, tax) {
  return price * (1 + tax);
}

// используется везде в файле
```

**Function expression** — когда функция используется как значение:

```js
// Колбэк
setTimeout(function() {
  console.log("Done");
}, 1000);

// Присваивание
const handler = function(event) {
  // обработка события
};
```

### Именованные function expressions

Function expression может иметь имя (полезно для отладки):

```js
const factorial = function fact(n) {
  if (n <= 1) return 1;
  return n * fact(n - 1);  // имя доступно только внутри функции
};

factorial(5);  // 120
fact(5);       // ReferenceError (имя недоступно снаружи)
```

### Arrow functions — разновидность function expression

Стрелочные функции — это тоже function expression:

```js
const add = (a, b) => a + b;  // function expression
```

### Сравнительная таблица

| Особенность | Function Declaration | Function Expression |
|-------------|---------------------|---------------------|
| Поднимается | ✅ Да (целиком) | ❌ Нет |
| Можно вызвать до объявления | ✅ Да | ❌ Нет |
| Имя обязательно | ✅ Да | ❌ Нет (может быть анонимной) |
| Использование | Основные функции | Колбэки, присваивания |

### ⚠️ Частая ошибка

```js
if (true) {
  function test() {
    console.log("A");
  }
} else {
  function test() {
    console.log("B");
  }
}

test();  // Результат непредсказуем!
```

Function declaration в блоках ведёт себя непредсказуемо. Используйте function expression:

```js
let test;

if (true) {
  test = function() {
    console.log("A");
  };
} else {
  test = function() {
    console.log("B");
  };
}
```

### Итоги

- Function declaration поднимается целиком, function expression — нет
- Function declaration имеет имя, function expression может быть анонимной
- Выбор зависит от контекста использования

---

## 19. Стрелочные функции и их особенности

Стрелочные функции (arrow functions) — это **короткий синтаксис** для создания функций, введённый в ES6.

### Базовый синтаксис

```js
// Обычная функция
const add1 = function(a, b) {
  return a + b;
};

// Стрелочная функция
const add2 = (a, b) => {
  return a + b;
};

// Короткий вариант (одна строка)
const add3 = (a, b) => a + b;
```

### Особенности синтаксиса

1. **Один параметр** — скобки можно опустить:
```js
const square = x => x * x;
```

2. **Без параметров** — скобки обязательны:
```js
const greet = () => "Hello";
```

3. **Несколько строк** — нужны фигурные скобки и `return`:
```js
const multiply = (a, b) => {
  const result = a * b;
  return result;
};
```

4. **Возврат объекта** — нужны скобки:
```js
const createUser = (name) => ({ name: name });
// или
const createUser = (name) => ({ name });  // короткая запись
```

### Главное отличие: нет своего `this`

Самое важное отличие — стрелочные функции **не имеют своего `this`**. Они берут `this` из внешней области видимости:

```js
const obj = {
  name: "Alex",
  
  regular: function() {
    setTimeout(function() {
      console.log(this.name);  // undefined (this === window/undefined)
    }, 100);
  },
  
  arrow: function() {
    setTimeout(() => {
      console.log(this.name);  // "Alex" ✅ (this === obj)
    }, 100);
  }
};
```

### Другие отличия

1. **Нет `arguments`**:
```js
function regular() {
  console.log(arguments);  // объект arguments
}

const arrow = () => {
  console.log(arguments);  // ReferenceError
};
```

2. **Нельзя использовать как конструктор**:
```js
const Regular = function(name) {
  this.name = name;
};
new Regular("Alex");  // ✅ работает

const Arrow = (name) => {
  this.name = name;
};
new Arrow("Alex");  // TypeError
```

3. **Нет `prototype`**:
```js
const regular = function() {};
console.log(regular.prototype);  // {} (есть)

const arrow = () => {};
console.log(arrow.prototype);    // undefined (нет)
```

### Когда использовать стрелочные функции?

✅ **Хорошо для:**
- Колбэков и коротких функций
- Методов массивов (`map`, `filter`, `reduce`)
- Когда нужно сохранить `this` из внешнего контекста

```js
const numbers = [1, 2, 3];
const doubled = numbers.map(n => n * 2);  // ✅ удобно
```

❌ **Не подходят для:**
- Методов объектов (нужен свой `this`)
- Конструкторов
- Функций с динамическим `this`
- Когда нужен `arguments`

```js
const obj = {
  name: "Alex",
  greet: () => {
    console.log(this.name);  // undefined ❌
  },
  greet2: function() {
    console.log(this.name);  // "Alex" ✅
  }
};
```

### Итоги

- Стрелочные функции — короткий синтаксис для функций
- Не имеют своего `this`, `arguments`, `prototype`
- Нельзя использовать как конструктор
- Удобны для колбэков и коротких функций

---

## 20. Есть ли у стрелочных функций `this`, `arguments`, `prototype`

Это важный вопрос на собеседованиях. Давайте разберёмся по пунктам.

### `this` — нет своего, берётся извне

Стрелочные функции **не имеют своего `this`**. Они берут `this` из внешней (лексической) области видимости:

```js
const obj = {
  name: "Alex",
  
  regular() {
    console.log(this.name);  // "Alex" (this === obj)
    
    function inner() {
      console.log(this.name);  // undefined (this === window/undefined)
    }
    inner();
  },
  
  arrow() {
    console.log(this.name);  // "Alex" (this === obj)
    
    const inner = () => {
      console.log(this.name);  // "Alex" ✅ (this === obj, из внешней области)
    };
    inner();
  }
};
```

### `arguments` — нет

У стрелочных функций **нет объекта `arguments`**:

```js
function regular() {
  console.log(arguments);  // [1, 2, 3]
}

regular(1, 2, 3);

const arrow = () => {
  console.log(arguments);  // ReferenceError ❌
};

arrow(1, 2, 3);
```

**Решение:** используйте rest-параметры:

```js
const arrow = (...args) => {
  console.log(args);  // [1, 2, 3] ✅
};
```

### `prototype` — нет

У стрелочных функций **нет свойства `prototype`**:

```js
function regular() {}
console.log(regular.prototype);  // {} ✅

const arrow = () => {};
console.log(arrow.prototype);    // undefined ❌
```

Это логично, потому что стрелочные функции нельзя использовать как конструктор.

### Почему так сделано?

Стрелочные функции создавались для **коротких колбэков**, где нужно было:
1. Сохранить `this` из внешнего контекста
2. Упростить синтаксис
3. Избежать проблем с `this` в колбэках

### Сводная таблица

| Свойство | Обычная функция | Стрелочная функция |
|----------|----------------|-------------------|
| `this` | Свой (зависит от вызова) | Нет (берётся извне) |
| `arguments` | Есть | Нет (используйте `...args`) |
| `prototype` | Есть | Нет |
| Можно использовать как конструктор | Да | Нет |

### Примеры использования

```js
// ✅ Хорошо — колбэк сохраняет this
class Component {
  constructor() {
    this.value = 10;
  }
  
  setup() {
    setTimeout(() => {
      console.log(this.value);  // 10 ✅
    }, 100);
  }
}

// ❌ Плохо — метод объекта нужен свой this
const obj = {
  name: "Alex",
  greet: () => {
    console.log(this.name);  // undefined ❌
  }
};

// ✅ Правильно
const obj2 = {
  name: "Alex",
  greet() {
    console.log(this.name);  // "Alex" ✅
  }
};
```

### Итоги

- У стрелочных функций **нет** своего `this` — берётся извне
- У стрелочных функций **нет** `arguments` — используйте `...args`
- У стрелочных функций **нет** `prototype`
- Используйте стрелочные функции для колбэков, обычные — для методов

---

## 21. Что такое `this` и как он определяется

`this` — это специальное ключевое слово, которое указывает на **контекст выполнения функции**. Его значение определяется **в момент вызова**, а не объявления.

### Важно понимать

`this` — это **не переменная**, а специальное значение, которое автоматически устанавливается при вызове функции. Оно зависит от **способа вызова**, а не от места объявления.

### Как определяется `this`?

#### 1. В методе объекта — `this` указывает на объект

```js
const obj = {
  name: "Alex",
  greet() {
    console.log(this.name);  // this === obj
  }
};

obj.greet();  // "Alex"
```

#### 2. В обычной функции — `this` зависит от режима

```js
function test() {
  console.log(this);
}

// В обычном режиме (браузер)
test();  // window (глобальный объект)

// В strict mode
"use strict";
function test() {
  console.log(this);  // undefined
}
```

#### 3. В стрелочной функции — `this` из внешней области

```js
const obj = {
  name: "Alex",
  regular() {
    const arrow = () => {
      console.log(this.name);  // this из regular (т.е. obj)
    };
    arrow();
  }
};
```

#### 4. С `new` — `this` указывает на новый объект

```js
function User(name) {
  this.name = name;  // this === новый объект
}

const user = new User("Alex");
console.log(user.name);  // "Alex"
```

#### 5. С `call`, `apply`, `bind` — `this` задаётся явно

```js
function greet() {
  console.log(this.name);
}

const obj = { name: "Alex" };
greet.call(obj);    // "Alex" (this === obj)
greet.apply(obj);   // "Alex" (this === obj)

const bound = greet.bind(obj);
bound();            // "Alex" (this === obj)
```

### Потеря контекста `this`

Частая проблема — потеря `this` при передаче метода:

```js
const obj = {
  name: "Alex",
  greet() {
    console.log(this.name);
  }
};

const fn = obj.greet;  // теряется контекст!
fn();  // undefined (this === window/undefined)
```

**Решения:**

1. Использовать стрелочную функцию:
```js
const fn = () => obj.greet();
fn();  // "Alex"
```

2. Использовать `bind`:
```js
const fn = obj.greet.bind(obj);
fn();  // "Alex"
```

### Визуальная аналогия

Представьте, что функция — это человек, а `this` — это "я":
- Когда человек говорит о себе в семье — "я" = этот человек
- Когда говорит на работе — "я" = сотрудник
- Когда говорит в другой стране — "я" = может быть по-другому

`this` меняется в зависимости от **контекста вызова**.

### Правила определения `this` (приоритет)

1. **`new`** — создаёт новый объект, `this` = новый объект
2. **`call`/`apply`/`bind`** — `this` задаётся явно
3. **Метод объекта** (`obj.method()`) — `this` = объект
4. **Обычная функция** — `this` = `window` (обычный режим) или `undefined` (strict mode)
5. **Стрелочная функция** — `this` из внешней области

### Итоги

- `this` определяется в момент вызова, а не объявления
- В методе объекта `this` = объект
- В обычной функции `this` = `window`/`undefined`
- В стрелочной функции `this` из внешней области
- Можно явно задать через `call`/`apply`/`bind`

---

## 22. Потеря контекста `this`

Потеря контекста `this` — одна из самых частых проблем в JavaScript. Давайте разберёмся, почему это происходит и как исправить.

### Что такое потеря контекста?

Потеря контекста происходит, когда метод объекта **отсоединяется от объекта** при передаче в другую функцию или переменную.

### Пример проблемы

```js
const user = {
  name: "Alex",
  greet() {
    console.log(`Привет, я ${this.name}`);
  }
};

user.greet();  // "Привет, я Alex" ✅

const fn = user.greet;  // метод отсоединился от объекта!
fn();  // "Привет, я undefined" ❌ (this === window/undefined)
```

### Почему это происходит?

Когда вы вызываете `user.greet()`, JavaScript знает, что `this` = `user`. Но когда вы сохраняете метод в переменную, **связь с объектом теряется**.

### Где часто возникает?

#### 1. Колбэки

```js
const button = {
  text: "Нажми меня",
  click() {
    console.log(this.text);
  }
};

setTimeout(button.click, 100);  // undefined ❌
```

#### 2. Обработчики событий

```js
const handler = {
  name: "Handler",
  handleClick() {
    console.log(this.name);
  }
};

document.addEventListener("click", handler.handleClick);  // undefined ❌
```

#### 3. Массивы методов

```js
const calculator = {
  numbers: [1, 2, 3],
  multiplier: 2,
  multiply() {
    return this.numbers.map(function(n) {
      return n * this.multiplier;  // undefined ❌
    });
  }
};
```

### Решения

#### 1. Стрелочная функция (рекомендуется)

```js
const user = {
  name: "Alex",
  greet() {
    console.log(`Привет, я ${this.name}`);
  }
};

const fn = () => user.greet();  // ✅
fn();  // "Привет, я Alex"

// В методах массивов
calculator.multiply = function() {
  return this.numbers.map(n => n * this.multiplier);  // ✅
};
```

#### 2. `bind`

```js
const fn = user.greet.bind(user);  // ✅
fn();  // "Привет, я Alex"

setTimeout(button.click.bind(button), 100);  // ✅
```

#### 3. `call`/`apply` (если вызываете сразу)

```js
setTimeout(() => button.click.call(button), 100);  // ✅
```

#### 4. Сохранение `this` в переменную

```js
const calculator = {
  numbers: [1, 2, 3],
  multiplier: 2,
  multiply() {
    const self = this;  // сохраняем this
    return this.numbers.map(function(n) {
      return n * self.multiplier;  // ✅
    });
  }
};
```

### Современный подход

В современном JavaScript используйте **стрелочные функции**:

```js
class Component {
  constructor() {
    this.value = 10;
  }
  
  setup() {
    // ✅ Стрелочная функция сохраняет this
    setTimeout(() => {
      console.log(this.value);
    }, 100);
    
    // ✅ В методах массивов
    [1, 2, 3].map(n => n * this.value);
  }
}
```

### ⚠️ Частая ошибка

```js
const obj = {
  name: "Alex",
  methods: {
    greet: () => {
      console.log(this.name);  // undefined ❌
      // Стрелочная функция в объекте НЕ имеет this объекта!
    }
  }
};
```

В этом случае стрелочная функция берёт `this` из глобальной области. Используйте обычную функцию:

```js
methods: {
  greet() {
    console.log(this.name);  // ✅
  }
}
```

### Итоги

- Потеря контекста происходит при отсоединении метода от объекта
- Решения: стрелочные функции, `bind`, сохранение `this`
- Используйте стрелочные функции для колбэков
- Обычные функции для методов объектов

---

## 23. `call`, `apply`, `bind` и разница между ними

Эти три метода позволяют **явно задать значение `this`** для функции. Но между ними есть важные отличия.

### `call` — вызывает функцию сразу

`call` вызывает функцию **немедленно** с указанным `this` и аргументами:

```js
function greet(greeting, punctuation) {
  console.log(`${greeting}, я ${this.name}${punctuation}`);
}

const person = { name: "Alex" };

greet.call(person, "Привет", "!");  // "Привет, я Alex!"
//        ↑this  ↑arg1   ↑arg2
```

**Синтаксис:** `func.call(thisArg, arg1, arg2, ...)`

### `apply` — вызывает функцию сразу, аргументы массивом

`apply` работает как `call`, но аргументы передаются **массивом**:

```js
function greet(greeting, punctuation) {
  console.log(`${greeting}, я ${this.name}${punctuation}`);
}

const person = { name: "Alex" };

greet.apply(person, ["Привет", "!"]);  // "Привет, я Alex!"
//        ↑this   ↑массив аргументов
```

**Синтаксис:** `func.apply(thisArg, [arg1, arg2, ...])`

### `bind` — возвращает новую функцию, не вызывает

`bind` **не вызывает** функцию, а возвращает **новую функцию** с привязанным `this`:

```js
function greet(greeting) {
  console.log(`${greeting}, я ${this.name}`);
}

const person = { name: "Alex" };

const boundGreet = greet.bind(person);  // не вызывает, а создаёт новую функцию
boundGreet("Привет");  // "Привет, я Alex"
```

**Синтаксис:** `func.bind(thisArg, arg1, arg2, ...)`

### Сравнительная таблица

| Метод | Вызывает функцию? | Возвращает | Аргументы |
|-------|------------------|------------|-----------|
| `call` | ✅ Да (сразу) | Результат функции | По отдельности |
| `apply` | ✅ Да (сразу) | Результат функции | Массивом |
| `bind` | ❌ Нет | Новую функцию | По отдельности (частичное применение) |

### Примеры использования

#### `call` — когда аргументов немного

```js
function introduce(age, city) {
  console.log(`Я ${this.name}, мне ${age}, из ${city}`);
}

const person = { name: "Alex" };
introduce.call(person, 25, "Москва");  // удобно с несколькими аргументами
```

#### `apply` — когда аргументы в массиве

```js
function sum() {
  return Array.from(arguments).reduce((a, b) => a + b, 0);
}

const numbers = [1, 2, 3, 4, 5];
sum.apply(null, numbers);  // 15 (this не важен, передаём null)
```

**Современная альтернатива с spread:**

```js
sum(...numbers);  // 15 (проще!)
```

#### `bind` — для колбэков

```js
const button = {
  text: "Нажми",
  click() {
    console.log(this.text);
  }
};

// Сохраняем метод с привязанным this
const boundClick = button.click.bind(button);
setTimeout(boundClick, 100);  // "Нажми" ✅
```

### Частичное применение с `bind`

`bind` может "зафиксировать" не только `this`, но и аргументы:

```js
function multiply(a, b, c) {
  return a * b * c;
}

const double = multiply.bind(null, 2);  // фиксируем первый аргумент
double(3, 4);  // 24 (2 * 3 * 4)

const triple = multiply.bind(null, 2, 3);  // фиксируем два аргумента
triple(4);  // 24 (2 * 3 * 4)
```

### Когда что использовать?

- **`call`** — когда нужно вызвать функцию сразу с другим `this`
- **`apply`** — когда аргументы в массиве (редко, обычно используют spread)
- **`bind`** — когда нужно сохранить функцию с привязанным `this` (колбэки)

### Современные альтернативы

В современном JavaScript часто используют стрелочные функции вместо `bind`:

```js
// Вместо bind
const fn = obj.method.bind(obj);

// Стрелочная функция
const fn = () => obj.method();
```

### Итоги

- `call` — вызывает сразу, аргументы по отдельности
- `apply` — вызывает сразу, аргументы массивом
- `bind` — не вызывает, возвращает новую функцию
- Используйте `bind` для колбэков, `call`/`apply` для немедленного вызова

---

## 24. Что такое IIFE

IIFE (Immediately Invoked Function Expression) — это функция, которая **выполняется сразу после объявления**.

### Синтаксис

```js
(function() {
  console.log("Выполнилась сразу!");
})();

// или

(function() {
  console.log("Выполнилась сразу!");
}());
```

Оба варианта эквивалентны. Скобки вокруг функции и `()` в конце обязательны.

### Зачем нужны IIFE?

#### 1. Изоляция переменных (до ES6)

До появления `let`/`const` IIFE использовались для создания изолированной области видимости:

```js
(function() {
  var x = 10;  // локальная переменная
  console.log(x);  // 10
})();

console.log(x);  // ReferenceError (x не доступна снаружи)
```

#### 2. Избежание конфликтов имён

```js
// Библиотека 1
(function() {
  var library = "Library 1";
  // код библиотеки
})();

// Библиотека 2
(function() {
  var library = "Library 2";  // не конфликтует с первой!
  // код библиотеки
})();
```

#### 3. Модульный паттерн (Module Pattern)

```js
const counter = (function() {
  let count = 0;  // приватная переменная
  
  return {
    increment() {
      count++;
    },
    getCount() {
      return count;
    }
  };
})();

counter.increment();
console.log(counter.getCount());  // 1
console.log(counter.count);       // undefined (приватная)
```

### Современная альтернатива

В современном JavaScript (ES6+) IIFE редко нужны, так как есть:

- `let`/`const` — блочная область видимости
- Модули (`import`/`export`) — изоляция кода

```js
// Вместо IIFE
{
  let x = 10;
  console.log(x);
}

// Или модули
// module.js
let x = 10;
export { x };
```

### Итоги

- IIFE — функция, вызываемая сразу после объявления
- Использовалась для изоляции переменных (до ES6)
- Современная альтернатива: `let`/`const` и модули

---

## 25. Как передаются аргументы в функции (по значению и по ссылке)

В JavaScript аргументы передаются **по значению**, но для объектов передаётся **копия ссылки**. Это важное различие!

### Примитивы передаются по значению

При передаче примитивного значения создаётся **копия**:

```js
function changeValue(x) {
  x = 20;  // изменяем копию
  console.log(x);  // 20
}

let a = 10;
changeValue(a);
console.log(a);  // 10 (не изменилось!)
```

### Объекты передаются по ссылке (копия ссылки)

При передаче объекта передаётся **копия ссылки** на объект, а не сам объект:

```js
function changeObject(obj) {
  obj.value = 20;      // изменяем содержимое объекта ✅
  obj = { value: 30 }; // переопределяем ссылку (не влияет на исходный объект)
}

let o = { value: 10 };
changeObject(o);
console.log(o.value);  // 20 (изменилось содержимое!)
```

**Важно:** нельзя заменить сам объект, но можно изменять его свойства.

### Визуальная аналогия

- **Примитив** — как ксерокопия документа: изменили копию, оригинал не пострадал
- **Объект** — как адрес дома: передали копию адреса, оба указывают на один дом, изменили дом — оба видят изменения

### Примеры

```js
// Примитивы
function addOne(num) {
  num = num + 1;
}

let x = 5;
addOne(x);
console.log(x);  // 5 (не изменилось)

// Объекты
function addProperty(obj) {
  obj.newProp = "новое";
}

let obj = {};
addProperty(obj);
console.log(obj.newProp);  // "новое" (изменилось!)
```

### ⚠️ Частая ошибка

Попытка заменить объект внутри функции:

```js
function replaceObject(obj) {
  obj = { new: "объект" };  // не работает!
}

let myObj = { old: "объект" };
replaceObject(myObj);
console.log(myObj);  // { old: "объект" } (не изменился!)
```

### Итоги

- Примитивы передаются по значению (копируется значение)
- Объекты передаются по ссылке (копируется ссылка)
- Можно изменять свойства объекта, но нельзя заменить сам объект

---

## 26. Что такое замыкание

Замыкание (closure) — это функция, которая имеет доступ к переменным из **внешней области видимости** даже после того, как внешняя функция завершилась.

### Простой пример

```js
function outer() {
  let x = 10;  // переменная внешней функции
  
  function inner() {
    console.log(x);  // имеет доступ к x из outer
  }
  
  return inner;
}

const fn = outer();  // outer завершилась
fn();  // 10 ✅ (inner всё ещё видит x!)
```

### Почему это работает?

Внешние переменные **не удаляются** из памяти, пока есть функция, которая на них ссылается. JavaScript "запоминает" окружение, в котором функция была создана.

### Практический пример — счётчик

```js
function createCounter() {
  let count = 0;  // приватная переменная
  
  return function() {
    count++;
    return count;
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

counter1();  // 1
counter1();  // 2
counter2();  // 1 (независимый счётчик!)
counter1();  // 3
```

Каждый вызов `createCounter()` создаёт **новое** замыкание с собственной переменной `count`.

### Замыкания в циклах (проблема)

Классическая проблема с `var`:

```js
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // 3, 3, 3 ❌ (все ссылаются на одну i)
  }, 100);
}
```

**Решения:**

1. Использовать `let`:
```js
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // 0, 1, 2 ✅
  }, 100);
}
```

2. IIFE:
```js
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);  // 0, 1, 2 ✅
    }, 100);
  })(i);
}
```

### Приватные переменные

Замыкания позволяют создавать приватные переменные:

```js
function createBankAccount(initialBalance) {
  let balance = initialBalance;  // приватная переменная
  
  return {
    deposit(amount) {
      balance += amount;
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
      }
    },
    getBalance() {
      return balance;
    }
  };
}

const account = createBankAccount(100);
account.deposit(50);
console.log(account.getBalance());  // 150
console.log(account.balance);       // undefined (приватная!)
```

### Итоги

- Замыкание — функция с доступом к внешним переменным
- Внешние переменные сохраняются в памяти
- Используется для приватных переменных и модулей
- Осторожно с замыканиями в циклах (используйте `let`)

---

## 27. Замыкания и приватные переменные

Замыкания — отличный способ создания **приватных переменных** в JavaScript, так как в языке нет встроенной поддержки приватности на уровне класса (до ES2022).

### Что такое приватные переменные?

Приватные переменные — переменные, к которым **нельзя обратиться напрямую** снаружи. Доступ к ним возможен только через методы.

### Создание приватных переменных через замыкания

```js
function createPerson(name) {
  let age = 0;  // приватная переменная
  
  return {
    getName() {
      return name;
    },
    getAge() {
      return age;
    },
    setAge(newAge) {
      if (newAge > 0) {
        age = newAge;
      }
    },
    haveBirthday() {
      age++;
    }
  };
}

const person = createPerson("Alex");
person.haveBirthday();
console.log(person.getAge());  // 1
console.log(person.age);       // undefined (приватная!)
person.age = 100;              // не работает (не меняет внутреннюю age)
console.log(person.getAge());  // 1 (не изменилось!)
```

### Модульный паттерн

Классический способ создания модулей с приватными переменными:

```js
const module = (function() {
  let privateVar = "секрет";
  
  function privateFunction() {
    return privateVar;
  }
  
  return {
    publicMethod() {
      return privateFunction();
    },
    anotherPublicMethod() {
      return "публичный метод";
    }
  };
})();

module.publicMethod();        // "секрет"
module.privateVar;            // undefined
module.privateFunction();     // TypeError
```

### Современная альтернатива (ES2022)

В современных версиях JavaScript можно использовать приватные поля класса:

```js
class Person {
  #age = 0;  // приватное поле
  
  constructor(name) {
    this.name = name;
  }
  
  getAge() {
    return this.#age;
  }
  
  setAge(age) {
    if (age > 0) {
      this.#age = age;
    }
  }
}

const person = new Person("Alex");
person.setAge(25);
console.log(person.getAge());  // 25
console.log(person.#age);      // SyntaxError (приватное поле!)
```

### Сравнение подходов

| Подход | Доступность | Совместимость |
|--------|-------------|---------------|
| Замыкания | ✅ Везде | ✅ Все браузеры |
| Приватные поля (`#`) | ✅ ES2022+ | ❌ Только современные браузеры |

### Когда использовать замыкания?

Замыкания для приватности полезны, когда:
- Нужна поддержка старых браузеров
- Создаёте библиотеку или модуль
- Нужна полная изоляция данных

### Итоги

- Замыкания позволяют создавать приватные переменные
- Приватные переменные недоступны снаружи
- Доступ только через методы
- Современная альтернатива — приватные поля классов (`#`)

---

## 28. Замыкания в циклах (`var` vs `let`)

Классическая проблема с замыканиями в циклах — одна из самых частых ошибок в JavaScript.

### Проблема с `var`

```js
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // 3, 3, 3 ❌
  }, 100);
}
```

**Почему так?** Все функции в `setTimeout` ссылаются на **одну и ту же переменную** `i`, которая к моменту выполнения уже равна 3.

### Решение 1: `let` (рекомендуется)

`let` создаёт **новую переменную** для каждой итерации:

```js
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // 0, 1, 2 ✅
  }, 100);
}
```

### Решение 2: IIFE

Можно использовать IIFE для создания новой области видимости:

```js
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);  // 0, 1, 2 ✅
    }, 100);
  })(i);
}
```

### Решение 3: `bind`

```js
function logIndex(i) {
  console.log(i);
}

for (var i = 0; i < 3; i++) {
  setTimeout(logIndex.bind(null, i), 100);  // 0, 1, 2 ✅
}
```

### Почему `let` работает?

При использовании `let` в цикле `for` JavaScript создаёт **новое лексическое окружение** для каждой итерации. Каждая функция замыкается на свою копию `i`.

### Визуальная аналогия

- **С `var`**: все функции смотрят на **одну и ту же** переменную в общей комнате
- **С `let`**: каждая функция находится в **своей комнате** со своей копией переменной

### Пример с массивом функций

```js
// С var — все функции возвращают 3
var functions = [];
for (var i = 0; i < 3; i++) {
  functions.push(function() {
    return i;  // все ссылаются на одну i
  });
}
functions[0]();  // 3 ❌
functions[1]();  // 3 ❌
functions[2]();  // 3 ❌

// С let — каждая функция возвращает свой индекс
let functions2 = [];
for (let i = 0; i < 3; i++) {
  functions2.push(function() {
    return i;  // каждая ссылается на свою i
  });
}
functions2[0]();  // 0 ✅
functions2[1]();  // 1 ✅
functions2[2]();  // 2 ✅
```

### Итоги

- С `var` все замыкания ссылаются на одну переменную
- С `let` каждая итерация создаёт новую переменную
- Используйте `let` в циклах для правильной работы замыканий

---

## 29. Изменяемы ли строки в JavaScript

**Нет**, строки в JavaScript **неизменяемы** (immutable). Любая операция, которая "изменяет" строку, на самом деле создаёт **новую строку**.

### Что означает неизменяемость?

Нельзя изменить символ в строке напрямую:

```js
let str = "hello";
str[0] = "H";  // не работает
console.log(str);  // "hello" (не изменилось!)
```

### Операции создают новые строки

Все методы строк возвращают **новую строку**, не изменяя исходную:

```js
let str = "hello";

let upper = str.toUpperCase();  // создаёт новую строку
console.log(str);   // "hello" (не изменилась)
console.log(upper); // "HELLO" (новая строка)

let trimmed = str.trim();       // новая строка
let replaced = str.replace("l", "L");  // новая строка
```

### Конкатенация создаёт новую строку

```js
let str = "hello";
str = str + "!";  // создаётся новая строка "hello!"
// исходная строка "hello" удаляется сборщиком мусора
```

### Почему строки неизменяемы?

Неизменяемость даёт преимущества:
1. **Безопасность** — нельзя случайно изменить строку
2. **Производительность** — строки можно переиспользовать
3. **Простые сравнения** — сравнение по значению быстрое

### Сравнение с массивами

Массивы **изменяемы**:

```js
let arr = [1, 2, 3];
arr.push(4);      // изменяет исходный массив
console.log(arr); // [1, 2, 3, 4]

let str = "hello";
str.toUpperCase(); // не изменяет исходную строку
console.log(str);  // "hello"
```

### Создание новой строки из существующей

Если нужно "изменить" строку, создайте новую:

```js
let str = "hello";
str = "H" + str.slice(1);  // создаёт новую строку "Hello"
console.log(str);  // "Hello"
```

### Итоги

- Строки неизменяемы — нельзя изменить символ напрямую
- Все операции со строками создают новые строки
- Исходная строка не изменяется
- Это обеспечивает безопасность и производительность

---

## 30. Что такое объект в JavaScript

Объект в JavaScript — это **коллекция пар "ключ-значение"**, где ключ — это строка (или Symbol), а значение — любой тип данных.

### Создание объекта

```js
// Литерал объекта
const person = {
  name: "Alex",
  age: 25,
  city: "Moscow"
};

// Через конструктор
const person2 = new Object();
person2.name = "Bob";
person2.age = 30;
```

### Структура объекта

```js
const obj = {
  key1: "value1",      // строка
  key2: 42,            // число
  key3: true,          // boolean
  key4: [1, 2, 3],     // массив
  key5: {              // вложенный объект
    nested: "value"
  },
  key6: function() {   // метод
    return "method";
  }
};
```

### Доступ к свойствам

```js
const person = { name: "Alex", age: 25 };

// Точечная нотация
person.name;  // "Alex"

// Скобочная нотация
person["name"];  // "Alex"
person["age"];   // 25

// Динамический ключ
const key = "name";
person[key];  // "Alex"
```

### Особенности объектов в JavaScript

1. **Динамические** — можно добавлять и удалять свойства:
```js
const obj = {};
obj.newProp = "новое свойство";
delete obj.newProp;
```

2. **Ссылочные** — хранятся по ссылке:
```js
const obj1 = { x: 1 };
const obj2 = obj1;  // копируется ссылка
obj2.x = 2;
console.log(obj1.x);  // 2 (изменился исходный объект!)
```

3. **Все — объекты** (почти):
   - Массивы — это объекты
   - Функции — это объекты
   - Даже примитивы имеют объекты-обёртки

### Типы значений в объектах

Ключи могут быть:
- **Строки** (автоматически, даже без кавычек)
- **Symbol** (уникальные идентификаторы)

```js
const obj = {
  "string key": "value",
  numberKey: 42,
  [Symbol("symbol")]: "symbol value"
};
```

### Методы объекта

Метод — это функция, хранящаяся как свойство объекта:

```js
const calculator = {
  x: 10,
  y: 5,
  add() {
    return this.x + this.y;
  },
  multiply() {
    return this.x * this.y;
  }
};

calculator.add();      // 15
calculator.multiply(); // 50
```

### Итоги

- Объект — коллекция пар "ключ-значение"
- Свойства могут быть любого типа
- Объекты динамические и ссылочные
- Массивы и функции — тоже объекты

---

Продолжение следует... (темы 31-71 будут добавлены в следующей части)
