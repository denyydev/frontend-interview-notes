# JavaScript Core — Конспект для Junior разработчиков

> Подробный конспект по основам JavaScript для подготовки к собеседованиям и изучения языка

---

## Содержание (Table of Contents)

1. [Типы данных в JavaScript](#1-типы-данных-в-javascript)
2. [Примитивные и ссылочные типы](#2-примитивные-и-ссылочные-типы)
3. [Truthy и falsy значения](#3-truthy-и-falsy-значения)
4. [`typeof` и его особенности](#4-typeof-и-его-особенности)
5. [Разница между `null` и `undefined`](#5-разница-между-null-и-undefined)
6. [Как проверить значение на `NaN`](#6-как-проверить-значение-на-nan)
7. [Разница между `isNaN` и `Number.isNaN`](#7-разница-между-isnan-и-numberisnan)
8. [Неявное приведение типов (type coercion)](#8-неявное-приведение-типов-type-coercion)
9. [Разница между `==` и `===`](#9-разница-между--и-)
10. [Странные примеры приведения типов](#10-странные-примеры-приведения-типов)
11. [Отличия `var`, `let` и `const`](#11-отличия-var-let-и-const)
12. [Temporal Dead Zone (TDZ)](#12-temporal-dead-zone-tdz)
13. [Block scope и function scope](#13-block-scope-и-function-scope)
14. [Strict mode в JavaScript](#14-strict-mode-в-javascript)
15. [Что такое hoisting и что именно поднимается](#15-что-такое-hoisting-и-что-именно-поднимается)
16. [Что такое область видимости (scope)](#16-что-такое-область-видимости-scope)
17. [Что такое лексическое окружение](#17-что-такое-лексическое-окружение)
18. [Разница между `function declaration` и `function expression`](#18-разница-между-function-declaration-и-function-expression)
19. [Стрелочные функции и их особенности](#19-стрелочные-функции-и-их-особенности)
20. [Есть ли у стрелочных функций `this`, `arguments`, `prototype`](#20-есть-ли-у-стрелочных-функций-this-arguments-prototype)
21. [Что такое `this` и как он определяется](#21-что-такое-this-и-как-он-определяется)
22. [Потеря контекста `this`](#22-потеря-контекста-this)
23. [`call`, `apply`, `bind` и разница между ними](#23-call-apply-bind-и-разница-между-ними)
24. [Что такое IIFE](#24-что-такое-iife)
25. [Как передаются аргументы в функции (по значению и по ссылке)](#25-как-передаются-аргументы-в-функции-по-значению-и-по-ссылке)
26. [Что такое замыкание](#26-что-такое-замыкание)
27. [Замыкания и приватные переменные](#27-замыкания-и-приватные-переменные)
28. [Замыкания в циклах (`var` vs `let`)](#28-замыкания-в-циклах-var-vs-let)
29. [Изменяемы ли строки в JavaScript](#29-изменяемы-ли-строки-в-javascript)
30. [Что такое объект в JavaScript](#30-что-такое-объект-в-javascript)
31. [Как проверить, что значение — массив](#31-как-проверить-что-значение--массив)
32. [Как проверить наличие свойства в объекте](#32-как-проверить-наличие-свойства-в-объекте)
33. [Разница между `in` и `hasOwnProperty`](#33-разница-между-in-и-hasownproperty)
34. [Итерация по объекту](#34-итерация-по-объекту)
35. [Почему `{}` !== `{}` и как сравниваются объекты](#35-почему----и-как-сравниваются-объекты)
36. [Что такое прототип](#36-что-такое-прототип)
37. [`__proto__`, `[[Prototype]]`, `Object.getPrototypeOf`](#37-__proto__-prototype-objectgetprototypeof)
38. [Цепочка прототипов](#38-цепочка-прототипов)
39. [Что находится в конце цепочки прототипов](#39-что-находится-в-конце-цепочки-прототипов)
40. [Поверхностное и глубокое копирование](#40-поверхностное-и-глубокое-копирование)
41. [Способы копирования объектов](#41-способы-копирования-объектов)
42. [Как сделать глубокую копию объекта](#42-как-сделать-глубокую-копию-объекта)
43. [Ограничения `JSON.parse(JSON.stringify())`](#43-ограничения-jsonparsejsonstringify)
44. [Какие типы данных теряются при `JSON.stringify`](#44-какие-типы-данных-теряются-при-jsonstringify)
45. [Мутация и иммутабельность](#45-мутация-и-иммутабельность)
46. [Методы массивов `map`, `filter`, `reduce`](#46-методы-массивов-map-filter-reduce)
47. [Разница между `map` и `forEach`](#47-разница-между-map-и-foreach)
48. [Методы массива `find`, `some`, `every`](#48-методы-массива-find-some-every)
49. [Мутирующие и немутирующие методы массивов](#49-мутирующие-и-немутирующие-методы-массивов)
50. [`Set`, `Map`, `WeakSet`, `WeakMap`](#50-set-map-weakset-weakmap)
51. [Отличие `Map` от обычного объекта](#51-отличие-map-от-обычного-объекта)
52. [Зачем нужны `WeakMap` и `WeakSet`](#52-зачем-нужны-weakmap-и-weakset)
53. [Что такое Promise](#53-что-такое-promise)
54. [Состояния Promise](#54-состояния-promise)
55. [Цепочки `.then`](#55-цепочки-then)
56. [Способы обработки ошибок в Promise](#56-способы-обработки-ошибок-в-promise)
57. [`Promise.all`, `Promise.race`, `Promise.allSettled`, `Promise.any`](#57-promiseall-promiserace-promiseallsettled-promiseany)
58. [Что происходит, если Promise в `Promise.all` отклоняется](#58-что-происходит-если-promise-в-promiseall-отклоняется)
59. [Что такое `async / await`](#59-что-такое-async--await)
60. [Что возвращает `async` функция](#60-что-возвращает-async-функция)
61. [Можно ли использовать `await` вне `async`](#61-можно-ли-использовать-await-вне-async)
62. [Что такое Event Loop и зачем он нужен](#62-что-такое-event-loop-и-зачем-он-нужен)
63. [Call Stack](#63-call-stack)
64. [Microtasks и Macrotasks](#64-microtasks-и-macrotasks)
65. [Порядок выполнения `async / await`](#65-порядок-выполнения-async--await)
66. [Когда реально выполняется `setTimeout`](#66-когда-реально-выполняется-settimeout)
67. [Порядок выполнения `Promise`, `setTimeout`, `async / await`](#67-порядок-выполнения-promise-settimeout-async--await)
68. [Как работает `try / catch / finally`](#68-как-работает-try--catch--finally)
69. [Как ловить ошибки в `async / await`](#69-как-ловить-ошибки-в-async--await)
70. [Почему `try/catch` не ловит ошибку в `setTimeout`](#70-почему-trycatch-не-ловит-ошибку-в-settimeout)
71. [Ключевые отличия ES5 и ES6+](#71-ключевые-отличия-es5-и-es6)

---

## 1. Типы данных в JavaScript

В JavaScript есть **8 основных типов данных**: 7 примитивных и 1 ссылочный.

### Примитивные типы (7 штук)

Примитивные типы — это простые значения, которые хранятся **непосредственно в переменной**.

1. **`string`** — строки текста
   ```js
   "Привет"
   'Мир'
   `Шаблонная строка`
   ```

2. **`number`** — числа (включая целые, дробные, `Infinity`, `-Infinity`, `NaN`)
   ```js
   42
   3.14
   Infinity
   -Infinity
   NaN
   ```

3. **`boolean`** — логические значения
   ```js
   true
   false
   ```

4. **`null`** — специальное значение, означающее "ничего" или "пусто"
   ```js
   null
   ```

5. **`undefined`** — значение, которое означает, что переменная не была инициализирована
   ```js
   undefined
   ```

6. **`symbol`** — уникальный идентификатор (используется редко, обычно для ключей объектов)
   ```js
   Symbol("описание")
   ```

7. **`bigint`** — целые числа произвольной точности (для очень больших чисел)
   ```js
   123n
   9007199254740991n
   ```

### Ссылочный тип (1 штука)

8. **`object`** — объекты, массивы, функции, даты и другие сложные структуры

   ```js
   { name: "Alex" }        // объект
   [1, 2, 3]              // массив
   function() {}          // функция
   new Date()             // дата
   ```

### Важные отличия

**Примитивы:**
- Хранятся **по значению** — при копировании создаётся новая копия
- **Неизменяемы** (immutable) — нельзя изменить значение напрямую
- Сравниваются **по значению**

**Объекты:**
- Хранятся **по ссылке** — при копировании копируется только ссылка
- **Изменяемы** (mutable) — можно изменять свойства
- Сравниваются **по ссылке**

---

## 2. Примитивные и ссылочные типы

Это важное различие, которое влияет на то, как работают переменные в JavaScript.

### Примитивные типы хранятся по значению

Когда вы копируете примитивное значение, создаётся **новая независимая копия**:

```js
let a = 10;
let b = a;  // копируем значение

b = 20;     // изменяем b

console.log(a);  // 10 — a не изменился!
console.log(b);  // 20
```

**Почему так?** Потому что `a` и `b` — это **две разные ячейки памяти** с независимыми значениями.

### Ссылочные типы хранятся по ссылке

Когда вы копируете объект, копируется **только ссылка** на тот же объект в памяти:

```js
let obj1 = { name: "Alex" };
let obj2 = obj1;  // копируем ссылку, а не сам объект!

obj2.name = "Bob";

console.log(obj1.name);  // "Bob" — obj1 тоже изменился!
console.log(obj2.name);  // "Bob"
```

**Почему так?** Потому что `obj1` и `obj2` **указывают на один и тот же объект** в памяти.

### Визуальная аналогия

Представьте:
- **Примитив** — это как **ксерокопия документа**: изменили копию — оригинал не пострадал
- **Объект** — это как **адрес дома**: два человека записали один адрес, пришли к одному дому, отремонтировали его — оба видят изменения

### Как создать независимую копию объекта?

Используйте способы копирования (подробнее в темах про копирование объектов):

```js
let obj1 = { name: "Alex" };
let obj2 = { ...obj1 };  // создаём новый объект

obj2.name = "Bob";
console.log(obj1.name);  // "Alex" — не изменился!
```

---

## 3. Truthy и falsy значения

В JavaScript любое значение в логическом контексте (например, в `if`) преобразуется в `true` или `false`. 

### Falsy значения (преобразуются в `false`)

В JavaScript всего **8 falsy значений**:

```js
false
0
-0
0n          // BigInt zero
""          // пустая строка
null
undefined
NaN
```

Все остальные значения — **truthy** (преобразуются в `true`).

### Truthy значения (преобразуются в `true`)

Это **все значения**, которые не являются falsy. Примеры:

```js
true
1, -1, 3.14
"hello", "0", "false"  // даже строка "false" — truthy!
[]
{}
function() {}
// и всё остальное
```

### Примеры использования

```js
if ("hello") {
  console.log("Выполнится");  // строка — truthy
}

if ("") {
  console.log("Не выполнится");  // пустая строка — falsy
}

if (0) {
  console.log("Не выполнится");  // 0 — falsy
}

if ([]) {
  console.log("Выполнится");  // пустой массив — truthy!
}

if ({}) {
  console.log("Выполнится");  // пустой объект — truthy!
}
```

### ⚠️ Частая ошибка

**Пустые массивы и объекты — truthy!** Это часто путает:

```js
let arr = [];

if (arr) {
  console.log("Массив существует");  // выполнится
}

if (arr.length === 0) {
  console.log("Массив пустой");  // правильная проверка на пустоту
}
```

### Проверка на существование значения

Для проверки, что значение не `null` и не `undefined`, можно использовать просто проверку в `if`:

```js
let value = null;

if (value) {
  console.log("Есть значение");
} else {
  console.log("Нет значения");  // выполнится
}
```

Но будьте осторожны: `0` и `""` тоже дадут `false`!

---

## 4. `typeof` и его особенности

Оператор `typeof` показывает тип значения. Но у него есть несколько **странных особенностей**, которые важно знать.

### Базовое использование

```js
typeof "hello"      // "string"
typeof 42           // "number"
typeof true         // "boolean"
typeof undefined    // "undefined"
typeof Symbol()     // "symbol"
typeof 123n         // "bigint"
typeof {}           // "object"
typeof []           // "object" (странно!)
typeof null         // "object" (баг JavaScript!)
typeof function(){} // "function"
```

### ⚠️ Особенность 1: `typeof null === "object"`

Это **исторический баг** JavaScript, который нельзя исправить из-за обратной совместимости:

```js
typeof null  // "object" (но null не объект!)
```

**Правильная проверка на `null`:**

```js
let value = null;

// Неправильно
if (typeof value === "object") {
  // может быть объект, массив ИЛИ null
}

// Правильно
if (value === null) {
  // точно null
}
```

### ⚠️ Особенность 2: `typeof NaN === "number"`

`NaN` (Not-a-Number) имеет тип `"number"`, хотя это "не число":

```js
typeof NaN  // "number" (странно!)

// Правильная проверка на NaN
Number.isNaN(NaN)        // true
Number.isNaN("abc")      // false
```

### ⚠️ Особенность 3: `typeof [] === "object"`

Массивы тоже считаются объектами:

```js
typeof []  // "object"

// Правильная проверка на массив
Array.isArray([])        // true
Array.isArray({})        // false
```

### ⚠️ Особенность 4: `typeof function(){} === "function"`

Функции считаются отдельным типом, хотя технически это объекты:

```js
typeof function(){}  // "function"
```

### Универсальная проверка типов

Для надёжной проверки типов комбинируйте `typeof` с другими проверками:

```js
function getType(value) {
  if (value === null) return "null";
  if (Array.isArray(value)) return "array";
  return typeof value;
}

getType(null)      // "null"
getType([])        // "array"
getType({})        // "object"
getType("hello")   // "string"
```

---

## 5. Разница между `null` и `undefined`

Это одна из самых частых тем на собеседованиях. Давайте разберёмся, в чём разница.

### `undefined` — значение не задано

`undefined` означает, что переменная **объявлена, но значение не присвоено**:

```js
let a;
console.log(a);  // undefined

let b = undefined;  // можно явно присвоить (но не рекомендуется)
```

**Когда появляется `undefined`:**
- Переменная объявлена, но не инициализирована
- Свойство объекта не существует
- Функция не вернула значение (неявно возвращает `undefined`)
- Параметр функции не передан

### `null` — явное "ничего"

`null` — это **явно заданное пустое значение**. Его присваивает разработчик:

```js
let user = null;  // явно указываем, что пользователя нет
```

**Когда используется `null`:**
- Когда нужно явно показать, что значение отсутствует
- Когда объект был удалён или не найден
- Как результат функции, когда ничего не найдено

### Сравнение

```js
undefined == null   // true (нестрогое сравнение)
undefined === null  // false (строгое сравнение)

typeof undefined  // "undefined"
typeof null       // "object" (баг JavaScript)
```

### Пример из практики

```js
function getUser(id) {
  let users = { 1: "Alex", 2: "Bob" };
  
  if (users[id]) {
    return users[id];
  }
  
  return null;  // явно показываем, что пользователь не найден
}

let user = getUser(999);
console.log(user);  // null

if (user === null) {
  console.log("Пользователь не найден");
}
```

### ⚠️ Частая ошибка

Не путайте отсутствие свойства и `null`:

```js
let obj = { name: null };

console.log(obj.name);      // null
console.log(obj.age);       // undefined (свойства нет)
console.log(obj.name === null);      // true
console.log(obj.age === undefined);  // true
```

### Когда что использовать?

- Используйте `undefined` для значений по умолчанию (параметры функций)
- Используйте `null` когда нужно явно показать "пусто" (например, когда пользователь вышел из системы)

---

## 6. Как проверить значение на `NaN`

`NaN` означает "Not-a-Number" (не число). Это специальное значение типа `number`, которое получается при невозможных математических операциях.

### Почему `NaN === NaN` не работает?

`NaN` **не равен самому себе** — это особенность стандарта IEEE 754:

```js
NaN === NaN  // false (странно, но так задумано!)
NaN == NaN   // false
```

Поэтому обычное сравнение не работает для проверки.

### ✅ Правильный способ: `Number.isNaN()`

**Рекомендуемый способ** — использовать `Number.isNaN()`:

```js
Number.isNaN(NaN)        // true
Number.isNaN(0 / 0)      // true
Number.isNaN("abc" - 1)  // true

Number.isNaN("abc")      // false (строка не NaN)
Number.isNaN(42)         // false
Number.isNaN(undefined)  // false
```

### ❌ Старый способ: `isNaN()` (не используйте!)

Старая функция `isNaN()` **приводит типы** и может давать неожиданные результаты:

```js
isNaN(NaN)       // true ✅
isNaN("abc")     // true ⚠️ (строку приводит к числу, получается NaN)
isNaN(undefined) // true ⚠️
isNaN({})        // true ⚠️

Number.isNaN("abc")     // false ✅ (не приводит типы)
Number.isNaN(undefined) // false ✅
```

### Разница между `isNaN` и `Number.isNaN`

| Значение | `isNaN()` | `Number.isNaN()` |
|----------|-----------|------------------|
| `NaN` | `true` ✅ | `true` ✅ |
| `"abc"` | `true` ⚠️ | `false` ✅ |
| `undefined` | `true` ⚠️ | `false` ✅ |
| `42` | `false` ✅ | `false` ✅ |

**Вывод:** всегда используйте `Number.isNaN()`.

### Альтернативный способ

Можно использовать тот факт, что `NaN` — единственное значение, которое не равно самому себе:

```js
function isNaNValue(value) {
  return value !== value;
}

isNaNValue(NaN)  // true
isNaNValue(42)   // false
```

Но `Number.isNaN()` более читаемый и явный.

### Примеры получения `NaN`

```js
0 / 0              // NaN
"abc" - 1          // NaN
"hello" * 2        // NaN
Math.sqrt(-1)      // NaN
parseInt("xyz")    // NaN
Number("abc")      // NaN
```

---

## 7. Разница между `isNaN` и `Number.isNaN`

Эта тема очень важна, потому что использование неправильной функции может привести к багам.

### `isNaN()` — старый способ с приведением типов

Функция `isNaN()` **сначала пытается преобразовать значение в число**, а потом проверяет, является ли оно `NaN`:

```js
isNaN(NaN)         // true ✅
isNaN("abc")       // true ⚠️ (превращает "abc" в NaN)
isNaN("123")       // false (превращает "123" в 123, это не NaN)
isNaN("")          // false (превращает "" в 0, это не NaN)
isNaN(undefined)   // true ⚠️ (превращает undefined в NaN)
isNaN(null)        // false (превращает null в 0)
isNaN({})          // true ⚠️ (объект не может быть числом)
```

**Проблема:** функция делает **две вещи сразу** — приводит тип И проверяет на `NaN`. Это путает.

### `Number.isNaN()` — современный способ без приведения типов

`Number.isNaN()` проверяет, является ли значение **точно `NaN`**, без приведения типов:

```js
Number.isNaN(NaN)         // true ✅
Number.isNaN("abc")       // false ✅ (это строка, не NaN)
Number.isNaN("123")       // false ✅
Number.isNaN("")          // false ✅
Number.isNaN(undefined)   // false ✅
Number.isNaN(null)        // false ✅
Number.isNaN({})          // false ✅
```

**Преимущество:** функция делает **только одну вещь** — проверяет, является ли значение `NaN`.

### Визуальная аналогия

Представьте проверку возраста:
- **`isNaN()`** — как спрашивать "это не число?" после попытки прочитать число. Если вы передали "abc", она сначала попытается прочитать, не получится, скажет "да, это не число"
- **`Number.isNaN()`** — как спрашивать "это точно значение NaN?" без попыток прочитать. "abc" — это строка, не `NaN`, поэтому ответ "нет"

### ⚠️ Частая ошибка

```js
let userInput = "123abc";

// Неправильно
if (isNaN(userInput)) {
  console.log("Не число");  // может сработать неожиданно
}

// Правильно
if (Number.isNaN(Number(userInput))) {
  console.log("Не число");
}

// Или ещё лучше
if (isNaN(userInput)) {
  console.log("Не число");  // isNaN() здесь уместна, т.к. нужна проверка "можно ли преобразовать в число"
}
```

### Когда что использовать?

- **`Number.isNaN(value)`** — когда нужно проверить, является ли значение **точно `NaN`**
- **`isNaN(value)`** — когда нужно проверить, **можно ли преобразовать значение в число** (но лучше использовать `Number.isNaN(Number(value))` или `isNaN(value)` явно)

**Рекомендация:** в современном коде используйте `Number.isNaN()`.

---

## 8. Неявное приведение типов (type coercion)

JavaScript **автоматически преобразует типы** в некоторых ситуациях. Это называется неявным приведением типов (type coercion).

### Когда происходит приведение типов?

Приведение типов происходит, когда операции требуют определённого типа, а получают другой:

1. **Арифметические операции** (кроме `+` со строками)
2. **Операторы сравнения** (`==`, `!=`, `>`, `<` и др.)
3. **Условия** (`if`, `while`, `? :`)
4. **Логические операторы** (`&&`, `||`, `!`)

### Преобразование в число

```js
"5" - 2      // 3 (строка → число)
"5" * 2      // 10
"5" / 2      // 2.5
-"5"         // -5
+"5"         // 5 (унарный плюс преобразует в число)

"abc" - 1    // NaN (нельзя преобразовать в число)
```

### Преобразование в строку

Оператор `+` со строками преобразует всё в строки:

```js
"5" + 2        // "52" (число → строка)
"Hello" + 42   // "Hello42"
5 + "2"        // "52"
"" + true      // "true"
"" + null      // "null"
```

### ⚠️ Особенность оператора `+`

`+` ведёт себя по-разному:
- Если хотя бы один операнд — строка → преобразует всё в строки
- Иначе → преобразует в числа

```js
1 + 2          // 3 (оба числа)
"1" + 2        // "12" (есть строка → строка)
1 + "2"        // "12" (есть строка → строка)
1 + 2 + "3"    // "33" (сначала 1+2=3, потом 3+"3"="33")
"1" + 2 + 3    // "123" (сначала "1"+2="12", потом "12"+3="123")
```

### Преобразование в boolean

В логических контекстах значения преобразуются в `true`/`false` (см. тему про truthy/falsy):

```js
if ("hello") { }        // строка → true
if (0) { }              // 0 → false
if ([]) { }             // массив → true
if ("") { }             // пустая строка → false
```

### Правила преобразования

**В число:**
- `null` → `0`
- `undefined` → `NaN`
- `""` (пустая строка) → `0`
- `"123"` → `123`
- `"abc"` → `NaN`
- `true` → `1`, `false` → `0`
- `[]` → `0` (пустой массив)
- `[5]` → `5` (массив с одним числом)
- `[1,2]` → `NaN`

**В строку:**
- `null` → `"null"`
- `undefined` → `"undefined"`
- `true` → `"true"`
- `[]` → `""` (пустой массив)
- `[1,2]` → `"1,2"`

### ⚠️ Частая ошибка

```js
let input = "5";
let result = input + 1;  // "51" (строка!), а не 6!

// Правильно
let result = Number(input) + 1;  // 6
// или
let result = +input + 1;  // 6
```

### Как избежать проблем?

1. **Используйте строгое сравнение** (`===` вместо `==`)
2. **Явно преобразуйте типы** перед операциями
3. **Используйте `Number()`, `String()`, `Boolean()`** для явного преобразования

```js
// Явное преобразование
Number("5") + 1        // 6
String(5) + "2"        // "52"
Boolean(0)             // false
```

---

## 9. Разница между `==` и `===`

Это одна из самых важных тем. Разница между этими операторами часто вызывает баги.

### `===` (строгое равенство)

`===` сравнивает **и тип, и значение**. Если типы разные — сразу возвращает `false`:

```js
5 === 5        // true
5 === "5"      // false (разные типы)
true === 1     // false
null === undefined  // false
```

### `==` (нестрогое равенство)

`==` **приводит типы** перед сравнением, что может давать неожиданные результаты:

```js
5 == 5         // true
5 == "5"       // true ⚠️ (строка "5" преобразуется в число 5)
true == 1      // true ⚠️ (true преобразуется в 1)
false == 0     // true ⚠️
null == undefined  // true ⚠️ (специальное правило)
"" == 0        // true ⚠️
[] == 0        // true ⚠️ (пустой массив → "" → 0)
```

### Правила преобразования в `==`

1. Если типы одинаковые → сравнивает как `===`
2. `null == undefined` → всегда `true` (и наоборот)
3. Если один операнд — число, другой — строка → строка → число
4. Если один — boolean → boolean → число (`true` → `1`, `false` → `0`)
5. Если один — объект → объект → примитив (через `valueOf()` или `toString()`)

### Примеры странного поведения

```js
[] == 0        // true ([] → "" → 0)
[0] == 0       // true ([0] → "0" → 0)
[1,2] == "1,2" // true

"" == false    // true ("" → 0, false → 0)
"0" == false   // true ("0" → 0, false → 0)

null == undefined  // true
null == 0       // false (null не преобразуется в 0 при ==)
undefined == 0  // false
```

### ⚠️ Частая ошибка

```js
let userInput = "0";

if (userInput == false) {
  console.log("Пусто");  // выполнится! ("0" == false → true)
}

// Правильно
if (userInput === "" || userInput === "0") {
  console.log("Пусто или ноль");
}
```

### Когда использовать что?

**Почти всегда используйте `===`** (строгое сравнение):
- Предсказуемое поведение
- Нет неожиданных преобразований
- Быстрее (не нужно преобразовывать типы)

**`==` используйте только если:**
- Вам действительно нужно сравнение с приведением типов
- Сравниваете `null` и `undefined` (но лучше явно: `value == null`)

### Рекомендации

В современном JavaScript **всегда используйте `===`**:

```js
// Хорошо ✅
if (value === 5) { }
if (value === null || value === undefined) { }
if (value == null) { }  // допустимо (проверяет и null, и undefined)

// Плохо ❌
if (value == 5) { }
```

### Сравнение объектов

**Важно:** `==` и `===` для объектов работают одинаково — сравнивают **ссылки**:

```js
{} === {}        // false (разные объекты)
[] === []        // false (разные массивы)

let obj = {};
obj === obj      // true (один и тот же объект)
```

---

## 10. Странные примеры приведения типов

JavaScript может выдавать очень неожиданные результаты из-за приведения типов. Вот самые известные примеры.

### `[] + {}` и `{} + []`

Результат зависит от контекста:

```js
[] + {}        // "[object Object]"
               // [] → "" → "" + "[object Object]"

{} + []        // 0 (в консоли браузера)
               // {} интерпретируется как пустой блок кода!
               // +[] → +"" → 0

({} + [])      // "[object Object]" (с скобками работает иначе)
```

### `'5' - 1` и `'5' + 1`

```js
'5' - 1        // 4 (строка → число)
'5' + 1        // "51" (число → строка, т.к. + со строками)
```

### Сравнения

```js
[] == 0        // true
               // [] → "" → 0

[] == false    // true
               // [] → "" → 0, false → 0

![] == false   // true
               // ![] → false, false == false

[] == ![]      // true ⚠️
               // [] → "" → 0
               // ![] → false → 0
               // 0 == 0 → true

[] == []       // false (объекты сравниваются по ссылке)
```

### Массивы и числа

```js
[1] + [2]      // "12"
               // [1] → "1", [2] → "2", "1" + "2" → "12"

[1,2] + [3,4]  // "1,23,4"
               // [1,2] → "1,2", [3,4] → "3,4"

[10] - [5]     // 5 (при - массивы → числа)
[10] * [5]     // 50
```

### Логические значения

```js
true + true    // 2 (true → 1)
true + false   // 1
false + false  // 0

true == 1      // true
true === 1     // false
```

### Пустые значения

```js
null + 1       // 1 (null → 0)
undefined + 1  // NaN (undefined → NaN)

null == 0      // false (null не преобразуется в 0 при ==)
undefined == 0 // false

!null          // true
!undefined     // true
```

### Зачем это знать?

Эти примеры показывают, **почему важно:**
1. Использовать строгое сравнение (`===`)
2. Явно преобразовывать типы
3. Понимать, как работает приведение типов

### ⚠️ Практический совет

В реальном коде избегайте таких ситуаций:

```js
// Плохо ❌
if (value == []) { }
let result = input + 5;  // может быть строкой!

// Хорошо ✅
if (Array.isArray(value) && value.length === 0) { }
let result = Number(input) + 5;
```

---

## 11. Отличия `var`, `let` и `const`

Это одна из самых важных тем ES6+. Понимание разницы критично для написания правильного кода.

### `var` — старый способ (не используйте!)

`var` имеет **функциональную область видимости** и **поднимается** (hoisting):

```js
function test() {
  if (true) {
    var x = 10;
  }
  console.log(x);  // 10 (доступна вне блока!)
}

console.log(y);  // undefined (не ошибка!)
var y = 20;
```

**Проблемы `var`:**
- Область видимости — вся функция, а не блок
- Поднимается со значением `undefined`
- Можно переопределять в той же области
- Нет защиты от ошибок

### `let` — современная замена `var`

`let` имеет **блочную область видимости** и находится в TDZ:

```js
function test() {
  if (true) {
    let x = 10;
  }
  console.log(x);  // ReferenceError (x не доступна)
}

console.log(y);  // ReferenceError (нельзя использовать до объявления)
let y = 20;
```

**Преимущества `let`:**
- Область видимости — только блок `{}`
- Нельзя использовать до объявления (TDZ)
- Нельзя переопределять в той же области
- Защита от случайных ошибок

### `const` — для констант

`const` похож на `let`, но **нельзя переопределять**:

```js
const x = 10;
x = 20;  // TypeError (нельзя изменить)

const obj = { name: "Alex" };
obj.name = "Bob";  // ✅ Можно! (изменяется содержимое объекта)
obj = {};          // ❌ TypeError (нельзя переопределить переменную)
```

**Важно:** `const` не делает объект неизменяемым, только переменную!

### Сравнительная таблица

| Особенность | `var` | `let` | `const` |
|-------------|-------|-------|---------|
| Область видимости | функция | блок | блок |
| Поднимается | да (со значением `undefined`) | да (TDZ) | да (TDZ) |
| Можно переопределять | да | нет | нет |
| Можно изменять значение | да | да | нет* |

*Нельзя переопределить переменную, но объект внутри можно изменять

### Примеры

```js
// var — плохо
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);  // 3, 3, 3 (все ссылаются на одну i)
}

// let — хорошо
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);  // 0, 1, 2 (каждая итерация — новая i)
}

// const для массива
const arr = [1, 2, 3];
arr.push(4);      // ✅ Можно
arr = [5, 6];     // ❌ Ошибка
```

### Рекомендации

1. **Всегда используйте `const` по умолчанию**
2. Используйте `let` только если переменная будет изменяться
3. **Никогда не используйте `var`** в новом коде

```js
// Хороший стиль
const name = "Alex";        // не изменяется
let counter = 0;            // будет изменяться
counter++;
```

---

## 12. Temporal Dead Zone (TDZ)

Temporal Dead Zone (TDZ) — это период между началом области видимости и объявлением переменной, когда к переменной **нельзя обратиться**.

### Что такое TDZ?

TDZ существует только для `let` и `const`. Это "мёртвая зона" до объявления переменной:

```js
// TDZ для x начинается здесь (начало области видимости)
console.log(x);  // ReferenceError (в TDZ)
let x = 10;      // TDZ заканчивается здесь
console.log(x);  // 10 (можно использовать)
```

### TDZ для `let`

```js
{
  // TDZ для a начинается
  console.log(a);  // ReferenceError: Cannot access 'a' before initialization
  let a = 5;
  // TDZ заканчивается
  console.log(a);  // 5
}
```

### TDZ для `const`

Работает так же:

```js
{
  console.log(b);  // ReferenceError
  const b = 10;
  console.log(b);  // 10
}
```

### `var` не имеет TDZ

`var` **поднимается** и инициализируется как `undefined`, поэтому TDZ нет:

```js
console.log(c);  // undefined (не ошибка!)
var c = 5;
console.log(c);  // 5
```

### Почему нужна TDZ?

TDZ **предотвращает ошибки**, заставляя объявлять переменные до использования:

```js
// С var — тихая ошибка
console.log(value);  // undefined (непонятно, почему)
var value = 10;

// С let — явная ошибка
console.log(value);  // ReferenceError (сразу видно проблему)
let value = 10;
```

### Примеры TDZ

```js
// TDZ в блоке
if (true) {
  console.log(x);  // ReferenceError
  let x = 1;
}

// TDZ в функции
function test() {
  console.log(y);  // ReferenceError
  let y = 2;
}

// TDZ в цикле
for (let i = 0; i < 3; i++) {
  // каждая итерация имеет свою TDZ для i
}
```

### ⚠️ Частая ошибка

```js
let x = 10;

function test() {
  console.log(x);  // ReferenceError (не глобальная x!)
  let x = 20;      // создаёт локальную x, которая находится в TDZ выше
}
```

Даже если есть глобальная `x`, локальная `x` "затеняет" её и находится в TDZ до объявления.

### TDZ и параметры функций

Параметры функции инициализируются **до** тела функции, поэтому TDZ для них нет:

```js
function test(x = y, y = 2) {
  // ReferenceError (y ещё не инициализирован при инициализации x)
}
```

### Итоги

- TDZ существует только для `let` и `const`
- TDZ начинается в начале области видимости и заканчивается при объявлении
- Обращение к переменной в TDZ вызывает `ReferenceError`
- TDZ помогает находить ошибки на этапе разработки

---

## 13. Block scope и function scope

Область видимости (scope) определяет, **где переменная доступна**. В JavaScript есть несколько типов областей видимости.

### Function scope (область видимости функции)

**Function scope** — переменная доступна **всей функции**, где она объявлена.

`var` имеет function scope:

```js
function test() {
  if (true) {
    var x = 10;  // объявлена в блоке if
  }
  console.log(x);  // 10 ✅ (доступна во всей функции)
}

console.log(x);  // ReferenceError (не доступна вне функции)
```

### Block scope (блочная область видимости)

**Block scope** — переменная доступна только **внутри блока** `{}`, где она объявлена.

`let` и `const` имеют block scope:

```js
function test() {
  if (true) {
    let x = 10;  // объявлена в блоке if
    const y = 20;
  }
  console.log(x);  // ReferenceError ❌ (не доступна вне блока)
  console.log(y);  // ReferenceError ❌
}

{
  let z = 30;
}
console.log(z);  // ReferenceError (не доступна вне блока)
```

### Визуальная аналогия

Представьте комнаты в здании:
- **Function scope** (`var`) — как комната в квартире: доступна везде в квартире (функции)
- **Block scope** (`let`/`const`) — как шкаф в комнате: доступен только в этой комнате (блоке)

### Примеры различий

```js
// var — function scope
function example1() {
  for (var i = 0; i < 3; i++) {
    // что-то делаем
  }
  console.log(i);  // 3 ✅ (доступна после цикла)
}

// let — block scope
function example2() {
  for (let i = 0; i < 3; i++) {
    // что-то делаем
  }
  console.log(i);  // ReferenceError ❌ (не доступна после цикла)
}
```

### Вложенные блоки

В block scope каждый блок создаёт свою область видимости:

```js
let a = 1;  // внешняя область

{
  let a = 2;  // внутренний блок (затеняет внешнюю a)
  console.log(a);  // 2
  
  {
    let a = 3;  // ещё более внутренний блок
    console.log(a);  // 3
  }
  
  console.log(a);  // 2
}

console.log(a);  // 1 (внешняя a)
```

### Почему block scope лучше?

Block scope **ограничивает область видимости**, что:
1. Предотвращает случайное использование переменных
2. Упрощает отладку (меньше конфликтов имён)
3. Позволяет переиспользовать имена в разных блоках

```js
// С var — проблема
function bad() {
  var result = "first";
  
  if (true) {
    var result = "second";  // переопределяет!
  }
  
  console.log(result);  // "second" (неожиданно)
}

// С let — безопасно
function good() {
  let result = "first";
  
  if (true) {
    let result = "second";  // новая переменная в блоке
  }
  
  console.log(result);  // "first" (ожидаемо)
}
```

### Глобальная область видимости

Переменные, объявленные вне функций и блоков, находятся в **глобальной области видимости**:

```js
let global = "доступна везде";

function test() {
  console.log(global);  // "доступна везде"
}
```

### Итоги

- **Function scope** (`var`) — переменная доступна во всей функции
- **Block scope** (`let`/`const`) — переменная доступна только в блоке `{}`
- Block scope безопаснее и предсказуемее
- Используйте `let`/`const` для block scope

---

## 14. Strict mode в JavaScript

Strict mode (строгий режим) делает JavaScript более строгим и помогает находить ошибки.

### Как включить strict mode?

Добавьте `"use strict";` в начало файла или функции:

```js
"use strict";

// весь код в файле в strict mode
```

Или в функции:

```js
function test() {
  "use strict";
  // только эта функция в strict mode
}
```

### Что меняет strict mode?

#### 1. Запрещает использование необъявленных переменных

```js
"use strict";

x = 10;  // ReferenceError (в обычном режиме создалась бы глобальная переменная)
```

#### 2. Меняет поведение `this`

В обычной функции `this` будет `undefined` вместо глобального объекта:

```js
"use strict";

function test() {
  console.log(this);  // undefined (в обычном режиме был бы window/global)
}
```

#### 3. Запрещает дублирование параметров

```js
"use strict";

function test(a, a) {  // SyntaxError
  // ...
}
```

#### 4. Запрещает удаление переменных и функций

```js
"use strict";

let x = 10;
delete x;  // SyntaxError (в обычном режиме просто проигнорировалось бы)
```

#### 5. Запрещает использование некоторых зарезервированных слов

```js
"use strict";

let let = 10;  // SyntaxError
```

#### 6. Делает ошибки из `eval` видимыми

В strict mode ошибки в `eval` не "заглушаются".

### Примеры различий

```js
// Обычный режим
function normal() {
  x = 10;  // создаётся глобальная переменная (плохо!)
  console.log(this);  // window (в браузере)
}

// Strict mode
function strict() {
  "use strict";
  x = 10;  // ReferenceError ✅
  console.log(this);  // undefined ✅
}
```

### ⚠️ Важно

Strict mode **включается для всего скрипта или функции**, где написан `"use strict"`. Его нельзя выключить в середине кода.

### Современные модули

В **ES6 модулях** (`import`/`export`) strict mode **включён по умолчанию**:

```js
// Модуль автоматически в strict mode
export function test() {
  x = 10;  // ReferenceError
}
```

### Рекомендации

1. **Всегда используйте strict mode** в новом коде
2. В модулях он уже включён
3. В обычных скриптах добавляйте `"use strict";` в начало

### Итоги

- Strict mode делает JavaScript строже и безопаснее
- Помогает находить ошибки на раннем этапе
- Включён по умолчанию в ES6 модулях
- Используйте его всегда в новом коде

---

## 15. Что такое hoisting и что именно поднимается

Hoisting (поднятие) — это механизм JavaScript, при котором объявления переменных и функций **"поднимаются"** в начало области видимости.

### Важно понимать

Hoisting — это **концептуальная модель**. На самом деле JavaScript не перемещает код. Но ведёт себя так, будто объявления выполнены первыми.

### Что поднимается?

Разные конструкции поднимаются по-разному:

#### 1. `var` — поднимается со значением `undefined`

```js
console.log(x);  // undefined (не ошибка!)
var x = 10;
console.log(x);  // 10
```

Это работает так, как будто написано:

```js
var x;           // объявление поднято
console.log(x);  // undefined
x = 10;          // присваивание осталось на месте
console.log(x);  // 10
```

#### 2. `let` и `const` — поднимаются, но в TDZ

```js
console.log(y);  // ReferenceError (в TDZ)
let y = 20;
```

Технически `let` тоже поднимается, но находится в Temporal Dead Zone до объявления.

#### 3. `function declaration` — поднимается целиком

```js
test();  // "Работает!" ✅ (можно вызвать до объявления)

function test() {
  console.log("Работает!");
}
```

Функция поднимается **со всем телом**, поэтому её можно вызвать до объявления.

#### 4. `function expression` — НЕ поднимается как функция

```js
test();  // TypeError (test === undefined)

var test = function() {
  console.log("Не работает");
};
```

Здесь поднимается только `var test`, а не функция. Поэтому `test` равен `undefined` до присваивания.

### Сравнительная таблица

| Конструкция | Поднимается? | Инициализация |
|-------------|--------------|---------------|
| `var` | ✅ Да | `undefined` |
| `let` | ✅ Да (TDZ) | Не инициализирована |
| `const` | ✅ Да (TDZ) | Не инициализирована |
| `function declaration` | ✅ Да | Вся функция |
| `function expression` | ❌ Нет | `undefined` (для `var`) |

### Примеры

```js
// var
console.log(a);  // undefined
var a = 1;

// let
console.log(b);  // ReferenceError
let b = 2;

// function declaration
foo();  // "Hello"
function foo() {
  console.log("Hello");
}

// function expression
bar();  // TypeError
var bar = function() {
  console.log("World");
};
```

### Порядок выполнения

При hoisting **функции имеют приоритет** над переменными:

```js
console.log(test);  // function test() { ... } (функция!)

var test = "переменная";

function test() {
  console.log("функция");
}
```

### ⚠️ Частая ошибка

```js
if (true) {
  function test() {
    console.log("A");
  }
} else {
  function test() {
    console.log("B");
  }
}

test();  // Результат зависит от реализации (непредсказуемо!)
```

Function declaration в блоках ведёт себя непредсказуемо. Используйте function expression.

### Рекомендации

1. **Всегда объявляйте переменные до использования**
2. Не полагайтесь на hoisting — это может запутать
3. Используйте `let`/`const` вместо `var` — они безопаснее

### Итоги

- Hoisting — концептуальная модель поведения JavaScript
- `var` поднимается как `undefined`
- `let`/`const` поднимаются, но в TDZ
- Function declaration поднимается целиком
- Function expression не поднимается как функция
- Лучше явно объявлять переменные до использования

---

## 16. Что такое область видимости (scope)

Область видимости (scope) — это **место в коде, где переменная доступна и может быть использована**.

### Типы областей видимости

В JavaScript есть три основных типа областей видимости:

1. **Глобальная область видимости** — переменные, объявленные вне функций и блоков
2. **Функциональная область видимости** — переменные доступны внутри функции (для `var`)
3. **Блочная область видимости** — переменные доступны только внутри блока `{}` (для `let`/`const`)

### Глобальная область видимости

Переменные, объявленные на верхнем уровне, доступны везде:

```js
let global = "доступна везде";

function test1() {
  console.log(global);  // "доступна везде"
}

function test2() {
  console.log(global);  // "доступна везде"
}
```

### Функциональная область видимости

`var` имеет функциональную область видимости — переменная доступна **во всей функции**:

```js
function test() {
  if (true) {
    var x = 10;  // объявлена в блоке
  }
  console.log(x);  // 10 ✅ (доступна во всей функции)
}
```

### Блочная область видимости

`let` и `const` имеют блочную область видимости — переменная доступна **только в блоке**:

```js
function test() {
  if (true) {
    let x = 10;  // объявлена в блоке
  }
  console.log(x);  // ReferenceError ❌ (не доступна вне блока)
}
```

### Вложенность областей видимости

Внутренние области видят внешние переменные, но не наоборот:

```js
let outer = "внешняя";

function test() {
  let middle = "средняя";
  
  if (true) {
    let inner = "внутренняя";
    console.log(outer);   // "внешняя" ✅
    console.log(middle);  // "средняя" ✅
    console.log(inner);   // "внутренняя" ✅
  }
  
  console.log(inner);  // ReferenceError ❌
}
```

### Поиск переменных (scope chain)

Когда JavaScript ищет переменную, он:
1. Сначала смотрит в текущей области видимости
2. Если не находит — поднимается на уровень выше
3. Продолжает до глобальной области
4. Если не находит — `ReferenceError`

```js
let global = "глобальная";

function outer() {
  let outerVar = "внешняя";
  
  function inner() {
    console.log(global);   // "глобальная" (найдена в глобальной области)
    console.log(outerVar); // "внешняя" (найдена во внешней функции)
  }
  
  inner();
}
```

### Затенение (shadowing)

Если во внутренней области объявить переменную с тем же именем, она "затенит" внешнюю:

```js
let x = "внешняя";

function test() {
  let x = "внутренняя";  // затеняет внешнюю x
  console.log(x);        // "внутренняя"
}

console.log(x);  // "внешняя" (не изменилась)
```

### Итоги

- Область видимости определяет доступность переменных
- JavaScript использует лексическую область видимости (определяется местом объявления)
- Внутренние области видят внешние переменные
- `var` имеет функциональную область, `let`/`const` — блочную

---

## 17. Что такое лексическое окружение

Лексическое окружение (Lexical Environment) — это внутренняя структура JavaScript, которая хранит **связь между идентификаторами (именами переменных) и их значениями**.

### Что это такое?

Простыми словами: лексическое окружение — это **"словарь"**, который хранит все переменные и функции в определённой области видимости.

### Структура лексического окружения

Каждое лексическое окружение содержит:

1. **Environment Record** (запись окружения) — объект, хранящий переменные и функции
2. **Ссылка на внешнее окружение** (outer reference) — ссылка на родительское окружение

```js
// Глобальное окружение
let global = "глобальная";  // хранится в глобальном Environment Record

function outer() {
  let outerVar = "внешняя";  // хранится в Environment Record функции outer
  
  function inner() {
    let innerVar = "внутренняя";  // хранится в Environment Record функции inner
    // inner имеет ссылку на окружение outer
    // outer имеет ссылку на глобальное окружение
  }
}
```

### Почему "лексическое"?

**Лексическое** означает, что структура окружения определяется **местом написания кода** (лексически), а не местом вызова.

```js
let x = "глобальная";

function outer() {
  let x = "внешняя";
  
  function inner() {
    console.log(x);  // "внешняя" (берётся из окружения, где функция объявлена)
  }
  
  return inner;
}

let innerFunc = outer();
innerFunc();  // "внешняя" (не "глобальная"!)
```

Функция `inner` "видит" `x` из `outer`, потому что была **объявлена** внутри `outer`, а не потому что была **вызвана** оттуда.

### Как работает поиск переменных?

При обращении к переменной JavaScript:

1. Ищет в текущем Environment Record
2. Если не находит — идёт по ссылке во внешнее окружение
3. Продолжает до глобального окружения
4. Если не находит — `ReferenceError`

Это называется **scope chain** (цепочка областей видимости).

### Пример с замыканием

Лексическое окружение — основа замыканий:

```js
function createCounter() {
  let count = 0;  // хранится в Environment Record createCounter
  
  return function() {
    count++;  // находит count во внешнем окружении (createCounter)
    return count;
  };
}

let counter = createCounter();
counter();  // 1
counter();  // 2
```

Функция "запоминает" окружение, в котором была создана, даже после завершения `createCounter`.

### Визуальная аналогия

Представьте матрёшку:
- Самая внешняя — глобальное окружение
- Внутри неё — окружения функций
- Каждая "знает" о внешней
- Внутренняя может видеть внешние переменные

### Итоги

- Лексическое окружение — внутренняя структура, хранящая переменные
- Определяется местом написания кода (лексически)
- Создаёт цепочку областей видимости (scope chain)
- Основа для работы замыканий

---

## 18. Разница между `function declaration` и `function expression`

В JavaScript функции можно создавать двумя способами, и между ними есть важные отличия.

### Function Declaration (объявление функции)

Function declaration — функция, объявленная как **отдельная инструкция**:

```js
function sayHello() {
  console.log("Hello");
}
```

**Особенности:**
- Поднимается (hoisting) **целиком** — можно вызвать до объявления
- Имеет имя (обязательно)
- Создаётся до выполнения кода

### Function Expression (функциональное выражение)

Function expression — функция, присвоенная **переменной**:

```js
const sayHello = function() {
  console.log("Hello");
};
```

**Особенности:**
- **Не поднимается** как функция (поднимается только переменная)
- Может быть анонимной или именованной
- Создаётся при выполнении кода

### Разница в hoisting

```js
// Function declaration
sayHi();  // "Hi!" ✅ (работает!)

function sayHi() {
  console.log("Hi!");
}

// Function expression
sayBye();  // TypeError ❌ (sayBye === undefined)

const sayBye = function() {
  console.log("Bye!");
};
```

### Когда что использовать?

**Function declaration** — когда функция — основная часть кода:

```js
function calculateTotal(price, tax) {
  return price * (1 + tax);
}

// используется везде в файле
```

**Function expression** — когда функция используется как значение:

```js
// Колбэк
setTimeout(function() {
  console.log("Done");
}, 1000);

// Присваивание
const handler = function(event) {
  // обработка события
};
```

### Именованные function expressions

Function expression может иметь имя (полезно для отладки):

```js
const factorial = function fact(n) {
  if (n <= 1) return 1;
  return n * fact(n - 1);  // имя доступно только внутри функции
};

factorial(5);  // 120
fact(5);       // ReferenceError (имя недоступно снаружи)
```

### Arrow functions — разновидность function expression

Стрелочные функции — это тоже function expression:

```js
const add = (a, b) => a + b;  // function expression
```

### Сравнительная таблица

| Особенность | Function Declaration | Function Expression |
|-------------|---------------------|---------------------|
| Поднимается | ✅ Да (целиком) | ❌ Нет |
| Можно вызвать до объявления | ✅ Да | ❌ Нет |
| Имя обязательно | ✅ Да | ❌ Нет (может быть анонимной) |
| Использование | Основные функции | Колбэки, присваивания |

### ⚠️ Частая ошибка

```js
if (true) {
  function test() {
    console.log("A");
  }
} else {
  function test() {
    console.log("B");
  }
}

test();  // Результат непредсказуем!
```

Function declaration в блоках ведёт себя непредсказуемо. Используйте function expression:

```js
let test;

if (true) {
  test = function() {
    console.log("A");
  };
} else {
  test = function() {
    console.log("B");
  };
}
```

### Итоги

- Function declaration поднимается целиком, function expression — нет
- Function declaration имеет имя, function expression может быть анонимной
- Выбор зависит от контекста использования

---

## 19. Стрелочные функции и их особенности

Стрелочные функции (arrow functions) — это **короткий синтаксис** для создания функций, введённый в ES6.

### Базовый синтаксис

```js
// Обычная функция
const add1 = function(a, b) {
  return a + b;
};

// Стрелочная функция
const add2 = (a, b) => {
  return a + b;
};

// Короткий вариант (одна строка)
const add3 = (a, b) => a + b;
```

### Особенности синтаксиса

1. **Один параметр** — скобки можно опустить:
```js
const square = x => x * x;
```

2. **Без параметров** — скобки обязательны:
```js
const greet = () => "Hello";
```

3. **Несколько строк** — нужны фигурные скобки и `return`:
```js
const multiply = (a, b) => {
  const result = a * b;
  return result;
};
```

4. **Возврат объекта** — нужны скобки:
```js
const createUser = (name) => ({ name: name });
// или
const createUser = (name) => ({ name });  // короткая запись
```

### Главное отличие: нет своего `this`

Самое важное отличие — стрелочные функции **не имеют своего `this`**. Они берут `this` из внешней области видимости:

```js
const obj = {
  name: "Alex",
  
  regular: function() {
    setTimeout(function() {
      console.log(this.name);  // undefined (this === window/undefined)
    }, 100);
  },
  
  arrow: function() {
    setTimeout(() => {
      console.log(this.name);  // "Alex" ✅ (this === obj)
    }, 100);
  }
};
```

### Другие отличия

1. **Нет `arguments`**:
```js
function regular() {
  console.log(arguments);  // объект arguments
}

const arrow = () => {
  console.log(arguments);  // ReferenceError
};
```

2. **Нельзя использовать как конструктор**:
```js
const Regular = function(name) {
  this.name = name;
};
new Regular("Alex");  // ✅ работает

const Arrow = (name) => {
  this.name = name;
};
new Arrow("Alex");  // TypeError
```

3. **Нет `prototype`**:
```js
const regular = function() {};
console.log(regular.prototype);  // {} (есть)

const arrow = () => {};
console.log(arrow.prototype);    // undefined (нет)
```

### Когда использовать стрелочные функции?

✅ **Хорошо для:**
- Колбэков и коротких функций
- Методов массивов (`map`, `filter`, `reduce`)
- Когда нужно сохранить `this` из внешнего контекста

```js
const numbers = [1, 2, 3];
const doubled = numbers.map(n => n * 2);  // ✅ удобно
```

❌ **Не подходят для:**
- Методов объектов (нужен свой `this`)
- Конструкторов
- Функций с динамическим `this`
- Когда нужен `arguments`

```js
const obj = {
  name: "Alex",
  greet: () => {
    console.log(this.name);  // undefined ❌
  },
  greet2: function() {
    console.log(this.name);  // "Alex" ✅
  }
};
```

### Итоги

- Стрелочные функции — короткий синтаксис для функций
- Не имеют своего `this`, `arguments`, `prototype`
- Нельзя использовать как конструктор
- Удобны для колбэков и коротких функций

---

## 20. Есть ли у стрелочных функций `this`, `arguments`, `prototype`

Это важный вопрос на собеседованиях. Давайте разберёмся по пунктам.

### `this` — нет своего, берётся извне

Стрелочные функции **не имеют своего `this`**. Они берут `this` из внешней (лексической) области видимости:

```js
const obj = {
  name: "Alex",
  
  regular() {
    console.log(this.name);  // "Alex" (this === obj)
    
    function inner() {
      console.log(this.name);  // undefined (this === window/undefined)
    }
    inner();
  },
  
  arrow() {
    console.log(this.name);  // "Alex" (this === obj)
    
    const inner = () => {
      console.log(this.name);  // "Alex" ✅ (this === obj, из внешней области)
    };
    inner();
  }
};
```

### `arguments` — нет

У стрелочных функций **нет объекта `arguments`**:

```js
function regular() {
  console.log(arguments);  // [1, 2, 3]
}

regular(1, 2, 3);

const arrow = () => {
  console.log(arguments);  // ReferenceError ❌
};

arrow(1, 2, 3);
```

**Решение:** используйте rest-параметры:

```js
const arrow = (...args) => {
  console.log(args);  // [1, 2, 3] ✅
};
```

### `prototype` — нет

У стрелочных функций **нет свойства `prototype`**:

```js
function regular() {}
console.log(regular.prototype);  // {} ✅

const arrow = () => {};
console.log(arrow.prototype);    // undefined ❌
```

Это логично, потому что стрелочные функции нельзя использовать как конструктор.

### Почему так сделано?

Стрелочные функции создавались для **коротких колбэков**, где нужно было:
1. Сохранить `this` из внешнего контекста
2. Упростить синтаксис
3. Избежать проблем с `this` в колбэках

### Сводная таблица

| Свойство | Обычная функция | Стрелочная функция |
|----------|----------------|-------------------|
| `this` | Свой (зависит от вызова) | Нет (берётся извне) |
| `arguments` | Есть | Нет (используйте `...args`) |
| `prototype` | Есть | Нет |
| Можно использовать как конструктор | Да | Нет |

### Примеры использования

```js
// ✅ Хорошо — колбэк сохраняет this
class Component {
  constructor() {
    this.value = 10;
  }
  
  setup() {
    setTimeout(() => {
      console.log(this.value);  // 10 ✅
    }, 100);
  }
}

// ❌ Плохо — метод объекта нужен свой this
const obj = {
  name: "Alex",
  greet: () => {
    console.log(this.name);  // undefined ❌
  }
};

// ✅ Правильно
const obj2 = {
  name: "Alex",
  greet() {
    console.log(this.name);  // "Alex" ✅
  }
};
```

### Итоги

- У стрелочных функций **нет** своего `this` — берётся извне
- У стрелочных функций **нет** `arguments` — используйте `...args`
- У стрелочных функций **нет** `prototype`
- Используйте стрелочные функции для колбэков, обычные — для методов

---

## 21. Что такое `this` и как он определяется

`this` — это специальное ключевое слово, которое указывает на **контекст выполнения функции**. Его значение определяется **в момент вызова**, а не объявления.

### Важно понимать

`this` — это **не переменная**, а специальное значение, которое автоматически устанавливается при вызове функции. Оно зависит от **способа вызова**, а не от места объявления.

### Как определяется `this`?

#### 1. В методе объекта — `this` указывает на объект

```js
const obj = {
  name: "Alex",
  greet() {
    console.log(this.name);  // this === obj
  }
};

obj.greet();  // "Alex"
```

#### 2. В обычной функции — `this` зависит от режима

```js
function test() {
  console.log(this);
}

// В обычном режиме (браузер)
test();  // window (глобальный объект)

// В strict mode
"use strict";
function test() {
  console.log(this);  // undefined
}
```

#### 3. В стрелочной функции — `this` из внешней области

```js
const obj = {
  name: "Alex",
  regular() {
    const arrow = () => {
      console.log(this.name);  // this из regular (т.е. obj)
    };
    arrow();
  }
};
```

#### 4. С `new` — `this` указывает на новый объект

```js
function User(name) {
  this.name = name;  // this === новый объект
}

const user = new User("Alex");
console.log(user.name);  // "Alex"
```

#### 5. С `call`, `apply`, `bind` — `this` задаётся явно

```js
function greet() {
  console.log(this.name);
}

const obj = { name: "Alex" };
greet.call(obj);    // "Alex" (this === obj)
greet.apply(obj);   // "Alex" (this === obj)

const bound = greet.bind(obj);
bound();            // "Alex" (this === obj)
```

### Потеря контекста `this`

Частая проблема — потеря `this` при передаче метода:

```js
const obj = {
  name: "Alex",
  greet() {
    console.log(this.name);
  }
};

const fn = obj.greet;  // теряется контекст!
fn();  // undefined (this === window/undefined)
```

**Решения:**

1. Использовать стрелочную функцию:
```js
const fn = () => obj.greet();
fn();  // "Alex"
```

2. Использовать `bind`:
```js
const fn = obj.greet.bind(obj);
fn();  // "Alex"
```

### Визуальная аналогия

Представьте, что функция — это человек, а `this` — это "я":
- Когда человек говорит о себе в семье — "я" = этот человек
- Когда говорит на работе — "я" = сотрудник
- Когда говорит в другой стране — "я" = может быть по-другому

`this` меняется в зависимости от **контекста вызова**.

### Правила определения `this` (приоритет)

1. **`new`** — создаёт новый объект, `this` = новый объект
2. **`call`/`apply`/`bind`** — `this` задаётся явно
3. **Метод объекта** (`obj.method()`) — `this` = объект
4. **Обычная функция** — `this` = `window` (обычный режим) или `undefined` (strict mode)
5. **Стрелочная функция** — `this` из внешней области

### Итоги

- `this` определяется в момент вызова, а не объявления
- В методе объекта `this` = объект
- В обычной функции `this` = `window`/`undefined`
- В стрелочной функции `this` из внешней области
- Можно явно задать через `call`/`apply`/`bind`

---

## 22. Потеря контекста `this`

Потеря контекста `this` — одна из самых частых проблем в JavaScript. Давайте разберёмся, почему это происходит и как исправить.

### Что такое потеря контекста?

Потеря контекста происходит, когда метод объекта **отсоединяется от объекта** при передаче в другую функцию или переменную.

### Пример проблемы

```js
const user = {
  name: "Alex",
  greet() {
    console.log(`Привет, я ${this.name}`);
  }
};

user.greet();  // "Привет, я Alex" ✅

const fn = user.greet;  // метод отсоединился от объекта!
fn();  // "Привет, я undefined" ❌ (this === window/undefined)
```

### Почему это происходит?

Когда вы вызываете `user.greet()`, JavaScript знает, что `this` = `user`. Но когда вы сохраняете метод в переменную, **связь с объектом теряется**.

### Где часто возникает?

#### 1. Колбэки

```js
const button = {
  text: "Нажми меня",
  click() {
    console.log(this.text);
  }
};

setTimeout(button.click, 100);  // undefined ❌
```

#### 2. Обработчики событий

```js
const handler = {
  name: "Handler",
  handleClick() {
    console.log(this.name);
  }
};

document.addEventListener("click", handler.handleClick);  // undefined ❌
```

#### 3. Массивы методов

```js
const calculator = {
  numbers: [1, 2, 3],
  multiplier: 2,
  multiply() {
    return this.numbers.map(function(n) {
      return n * this.multiplier;  // undefined ❌
    });
  }
};
```

### Решения

#### 1. Стрелочная функция (рекомендуется)

```js
const user = {
  name: "Alex",
  greet() {
    console.log(`Привет, я ${this.name}`);
  }
};

const fn = () => user.greet();  // ✅
fn();  // "Привет, я Alex"

// В методах массивов
calculator.multiply = function() {
  return this.numbers.map(n => n * this.multiplier);  // ✅
};
```

#### 2. `bind`

```js
const fn = user.greet.bind(user);  // ✅
fn();  // "Привет, я Alex"

setTimeout(button.click.bind(button), 100);  // ✅
```

#### 3. `call`/`apply` (если вызываете сразу)

```js
setTimeout(() => button.click.call(button), 100);  // ✅
```

#### 4. Сохранение `this` в переменную

```js
const calculator = {
  numbers: [1, 2, 3],
  multiplier: 2,
  multiply() {
    const self = this;  // сохраняем this
    return this.numbers.map(function(n) {
      return n * self.multiplier;  // ✅
    });
  }
};
```

### Современный подход

В современном JavaScript используйте **стрелочные функции**:

```js
class Component {
  constructor() {
    this.value = 10;
  }
  
  setup() {
    // ✅ Стрелочная функция сохраняет this
    setTimeout(() => {
      console.log(this.value);
    }, 100);
    
    // ✅ В методах массивов
    [1, 2, 3].map(n => n * this.value);
  }
}
```

### ⚠️ Частая ошибка

```js
const obj = {
  name: "Alex",
  methods: {
    greet: () => {
      console.log(this.name);  // undefined ❌
      // Стрелочная функция в объекте НЕ имеет this объекта!
    }
  }
};
```

В этом случае стрелочная функция берёт `this` из глобальной области. Используйте обычную функцию:

```js
methods: {
  greet() {
    console.log(this.name);  // ✅
  }
}
```

### Итоги

- Потеря контекста происходит при отсоединении метода от объекта
- Решения: стрелочные функции, `bind`, сохранение `this`
- Используйте стрелочные функции для колбэков
- Обычные функции для методов объектов

---

## 23. `call`, `apply`, `bind` и разница между ними

Эти три метода позволяют **явно задать значение `this`** для функции. Но между ними есть важные отличия.

### `call` — вызывает функцию сразу

`call` вызывает функцию **немедленно** с указанным `this` и аргументами:

```js
function greet(greeting, punctuation) {
  console.log(`${greeting}, я ${this.name}${punctuation}`);
}

const person = { name: "Alex" };

greet.call(person, "Привет", "!");  // "Привет, я Alex!"
//        ↑this  ↑arg1   ↑arg2
```

**Синтаксис:** `func.call(thisArg, arg1, arg2, ...)`

### `apply` — вызывает функцию сразу, аргументы массивом

`apply` работает как `call`, но аргументы передаются **массивом**:

```js
function greet(greeting, punctuation) {
  console.log(`${greeting}, я ${this.name}${punctuation}`);
}

const person = { name: "Alex" };

greet.apply(person, ["Привет", "!"]);  // "Привет, я Alex!"
//        ↑this   ↑массив аргументов
```

**Синтаксис:** `func.apply(thisArg, [arg1, arg2, ...])`

### `bind` — возвращает новую функцию, не вызывает

`bind` **не вызывает** функцию, а возвращает **новую функцию** с привязанным `this`:

```js
function greet(greeting) {
  console.log(`${greeting}, я ${this.name}`);
}

const person = { name: "Alex" };

const boundGreet = greet.bind(person);  // не вызывает, а создаёт новую функцию
boundGreet("Привет");  // "Привет, я Alex"
```

**Синтаксис:** `func.bind(thisArg, arg1, arg2, ...)`

### Сравнительная таблица

| Метод | Вызывает функцию? | Возвращает | Аргументы |
|-------|------------------|------------|-----------|
| `call` | ✅ Да (сразу) | Результат функции | По отдельности |
| `apply` | ✅ Да (сразу) | Результат функции | Массивом |
| `bind` | ❌ Нет | Новую функцию | По отдельности (частичное применение) |

### Примеры использования

#### `call` — когда аргументов немного

```js
function introduce(age, city) {
  console.log(`Я ${this.name}, мне ${age}, из ${city}`);
}

const person = { name: "Alex" };
introduce.call(person, 25, "Москва");  // удобно с несколькими аргументами
```

#### `apply` — когда аргументы в массиве

```js
function sum() {
  return Array.from(arguments).reduce((a, b) => a + b, 0);
}

const numbers = [1, 2, 3, 4, 5];
sum.apply(null, numbers);  // 15 (this не важен, передаём null)
```

**Современная альтернатива с spread:**

```js
sum(...numbers);  // 15 (проще!)
```

#### `bind` — для колбэков

```js
const button = {
  text: "Нажми",
  click() {
    console.log(this.text);
  }
};

// Сохраняем метод с привязанным this
const boundClick = button.click.bind(button);
setTimeout(boundClick, 100);  // "Нажми" ✅
```

### Частичное применение с `bind`

`bind` может "зафиксировать" не только `this`, но и аргументы:

```js
function multiply(a, b, c) {
  return a * b * c;
}

const double = multiply.bind(null, 2);  // фиксируем первый аргумент
double(3, 4);  // 24 (2 * 3 * 4)

const triple = multiply.bind(null, 2, 3);  // фиксируем два аргумента
triple(4);  // 24 (2 * 3 * 4)
```

### Когда что использовать?

- **`call`** — когда нужно вызвать функцию сразу с другим `this`
- **`apply`** — когда аргументы в массиве (редко, обычно используют spread)
- **`bind`** — когда нужно сохранить функцию с привязанным `this` (колбэки)

### Современные альтернативы

В современном JavaScript часто используют стрелочные функции вместо `bind`:

```js
// Вместо bind
const fn = obj.method.bind(obj);

// Стрелочная функция
const fn = () => obj.method();
```

### Итоги

- `call` — вызывает сразу, аргументы по отдельности
- `apply` — вызывает сразу, аргументы массивом
- `bind` — не вызывает, возвращает новую функцию
- Используйте `bind` для колбэков, `call`/`apply` для немедленного вызова

---

## 24. Что такое IIFE

IIFE (Immediately Invoked Function Expression) — это функция, которая **выполняется сразу после объявления**.

### Синтаксис

```js
(function() {
  console.log("Выполнилась сразу!");
})();

// или

(function() {
  console.log("Выполнилась сразу!");
}());
```

Оба варианта эквивалентны. Скобки вокруг функции и `()` в конце обязательны.

### Зачем нужны IIFE?

#### 1. Изоляция переменных (до ES6)

До появления `let`/`const` IIFE использовались для создания изолированной области видимости:

```js
(function() {
  var x = 10;  // локальная переменная
  console.log(x);  // 10
})();

console.log(x);  // ReferenceError (x не доступна снаружи)
```

#### 2. Избежание конфликтов имён

```js
// Библиотека 1
(function() {
  var library = "Library 1";
  // код библиотеки
})();

// Библиотека 2
(function() {
  var library = "Library 2";  // не конфликтует с первой!
  // код библиотеки
})();
```

#### 3. Модульный паттерн (Module Pattern)

```js
const counter = (function() {
  let count = 0;  // приватная переменная
  
  return {
    increment() {
      count++;
    },
    getCount() {
      return count;
    }
  };
})();

counter.increment();
console.log(counter.getCount());  // 1
console.log(counter.count);       // undefined (приватная)
```

### Современная альтернатива

В современном JavaScript (ES6+) IIFE редко нужны, так как есть:

- `let`/`const` — блочная область видимости
- Модули (`import`/`export`) — изоляция кода

```js
// Вместо IIFE
{
  let x = 10;
  console.log(x);
}

// Или модули
// module.js
let x = 10;
export { x };
```

### Итоги

- IIFE — функция, вызываемая сразу после объявления
- Использовалась для изоляции переменных (до ES6)
- Современная альтернатива: `let`/`const` и модули

---

## 25. Как передаются аргументы в функции (по значению и по ссылке)

В JavaScript аргументы передаются **по значению**, но для объектов передаётся **копия ссылки**. Это важное различие!

### Примитивы передаются по значению

При передаче примитивного значения создаётся **копия**:

```js
function changeValue(x) {
  x = 20;  // изменяем копию
  console.log(x);  // 20
}

let a = 10;
changeValue(a);
console.log(a);  // 10 (не изменилось!)
```

### Объекты передаются по ссылке (копия ссылки)

При передаче объекта передаётся **копия ссылки** на объект, а не сам объект:

```js
function changeObject(obj) {
  obj.value = 20;      // изменяем содержимое объекта ✅
  obj = { value: 30 }; // переопределяем ссылку (не влияет на исходный объект)
}

let o = { value: 10 };
changeObject(o);
console.log(o.value);  // 20 (изменилось содержимое!)
```

**Важно:** нельзя заменить сам объект, но можно изменять его свойства.

### Визуальная аналогия

- **Примитив** — как ксерокопия документа: изменили копию, оригинал не пострадал
- **Объект** — как адрес дома: передали копию адреса, оба указывают на один дом, изменили дом — оба видят изменения

### Примеры

```js
// Примитивы
function addOne(num) {
  num = num + 1;
}

let x = 5;
addOne(x);
console.log(x);  // 5 (не изменилось)

// Объекты
function addProperty(obj) {
  obj.newProp = "новое";
}

let obj = {};
addProperty(obj);
console.log(obj.newProp);  // "новое" (изменилось!)
```

### ⚠️ Частая ошибка

Попытка заменить объект внутри функции:

```js
function replaceObject(obj) {
  obj = { new: "объект" };  // не работает!
}

let myObj = { old: "объект" };
replaceObject(myObj);
console.log(myObj);  // { old: "объект" } (не изменился!)
```

### Итоги

- Примитивы передаются по значению (копируется значение)
- Объекты передаются по ссылке (копируется ссылка)
- Можно изменять свойства объекта, но нельзя заменить сам объект

---

## 26. Что такое замыкание

Замыкание (closure) — это функция, которая имеет доступ к переменным из **внешней области видимости** даже после того, как внешняя функция завершилась.

### Простой пример

```js
function outer() {
  let x = 10;  // переменная внешней функции
  
  function inner() {
    console.log(x);  // имеет доступ к x из outer
  }
  
  return inner;
}

const fn = outer();  // outer завершилась
fn();  // 10 ✅ (inner всё ещё видит x!)
```

### Почему это работает?

Внешние переменные **не удаляются** из памяти, пока есть функция, которая на них ссылается. JavaScript "запоминает" окружение, в котором функция была создана.

### Практический пример — счётчик

```js
function createCounter() {
  let count = 0;  // приватная переменная
  
  return function() {
    count++;
    return count;
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

counter1();  // 1
counter1();  // 2
counter2();  // 1 (независимый счётчик!)
counter1();  // 3
```

Каждый вызов `createCounter()` создаёт **новое** замыкание с собственной переменной `count`.

### Замыкания в циклах (проблема)

Классическая проблема с `var`:

```js
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // 3, 3, 3 ❌ (все ссылаются на одну i)
  }, 100);
}
```

**Решения:**

1. Использовать `let`:
```js
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // 0, 1, 2 ✅
  }, 100);
}
```

2. IIFE:
```js
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);  // 0, 1, 2 ✅
    }, 100);
  })(i);
}
```

### Приватные переменные

Замыкания позволяют создавать приватные переменные:

```js
function createBankAccount(initialBalance) {
  let balance = initialBalance;  // приватная переменная
  
  return {
    deposit(amount) {
      balance += amount;
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
      }
    },
    getBalance() {
      return balance;
    }
  };
}

const account = createBankAccount(100);
account.deposit(50);
console.log(account.getBalance());  // 150
console.log(account.balance);       // undefined (приватная!)
```

### Итоги

- Замыкание — функция с доступом к внешним переменным
- Внешние переменные сохраняются в памяти
- Используется для приватных переменных и модулей
- Осторожно с замыканиями в циклах (используйте `let`)

---

## 27. Замыкания и приватные переменные

Замыкания — отличный способ создания **приватных переменных** в JavaScript, так как в языке нет встроенной поддержки приватности на уровне класса (до ES2022).

### Что такое приватные переменные?

Приватные переменные — переменные, к которым **нельзя обратиться напрямую** снаружи. Доступ к ним возможен только через методы.

### Создание приватных переменных через замыкания

```js
function createPerson(name) {
  let age = 0;  // приватная переменная
  
  return {
    getName() {
      return name;
    },
    getAge() {
      return age;
    },
    setAge(newAge) {
      if (newAge > 0) {
        age = newAge;
      }
    },
    haveBirthday() {
      age++;
    }
  };
}

const person = createPerson("Alex");
person.haveBirthday();
console.log(person.getAge());  // 1
console.log(person.age);       // undefined (приватная!)
person.age = 100;              // не работает (не меняет внутреннюю age)
console.log(person.getAge());  // 1 (не изменилось!)
```

### Модульный паттерн

Классический способ создания модулей с приватными переменными:

```js
const module = (function() {
  let privateVar = "секрет";
  
  function privateFunction() {
    return privateVar;
  }
  
  return {
    publicMethod() {
      return privateFunction();
    },
    anotherPublicMethod() {
      return "публичный метод";
    }
  };
})();

module.publicMethod();        // "секрет"
module.privateVar;            // undefined
module.privateFunction();     // TypeError
```

### Современная альтернатива (ES2022)

В современных версиях JavaScript можно использовать приватные поля класса:

```js
class Person {
  #age = 0;  // приватное поле
  
  constructor(name) {
    this.name = name;
  }
  
  getAge() {
    return this.#age;
  }
  
  setAge(age) {
    if (age > 0) {
      this.#age = age;
    }
  }
}

const person = new Person("Alex");
person.setAge(25);
console.log(person.getAge());  // 25
console.log(person.#age);      // SyntaxError (приватное поле!)
```

### Сравнение подходов

| Подход | Доступность | Совместимость |
|--------|-------------|---------------|
| Замыкания | ✅ Везде | ✅ Все браузеры |
| Приватные поля (`#`) | ✅ ES2022+ | ❌ Только современные браузеры |

### Когда использовать замыкания?

Замыкания для приватности полезны, когда:
- Нужна поддержка старых браузеров
- Создаёте библиотеку или модуль
- Нужна полная изоляция данных

### Итоги

- Замыкания позволяют создавать приватные переменные
- Приватные переменные недоступны снаружи
- Доступ только через методы
- Современная альтернатива — приватные поля классов (`#`)

---

## 28. Замыкания в циклах (`var` vs `let`)

Классическая проблема с замыканиями в циклах — одна из самых частых ошибок в JavaScript.

### Проблема с `var`

```js
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // 3, 3, 3 ❌
  }, 100);
}
```

**Почему так?** Все функции в `setTimeout` ссылаются на **одну и ту же переменную** `i`, которая к моменту выполнения уже равна 3.

### Решение 1: `let` (рекомендуется)

`let` создаёт **новую переменную** для каждой итерации:

```js
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // 0, 1, 2 ✅
  }, 100);
}
```

### Решение 2: IIFE

Можно использовать IIFE для создания новой области видимости:

```js
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);  // 0, 1, 2 ✅
    }, 100);
  })(i);
}
```

### Решение 3: `bind`

```js
function logIndex(i) {
  console.log(i);
}

for (var i = 0; i < 3; i++) {
  setTimeout(logIndex.bind(null, i), 100);  // 0, 1, 2 ✅
}
```

### Почему `let` работает?

При использовании `let` в цикле `for` JavaScript создаёт **новое лексическое окружение** для каждой итерации. Каждая функция замыкается на свою копию `i`.

### Визуальная аналогия

- **С `var`**: все функции смотрят на **одну и ту же** переменную в общей комнате
- **С `let`**: каждая функция находится в **своей комнате** со своей копией переменной

### Пример с массивом функций

```js
// С var — все функции возвращают 3
var functions = [];
for (var i = 0; i < 3; i++) {
  functions.push(function() {
    return i;  // все ссылаются на одну i
  });
}
functions[0]();  // 3 ❌
functions[1]();  // 3 ❌
functions[2]();  // 3 ❌

// С let — каждая функция возвращает свой индекс
let functions2 = [];
for (let i = 0; i < 3; i++) {
  functions2.push(function() {
    return i;  // каждая ссылается на свою i
  });
}
functions2[0]();  // 0 ✅
functions2[1]();  // 1 ✅
functions2[2]();  // 2 ✅
```

### Итоги

- С `var` все замыкания ссылаются на одну переменную
- С `let` каждая итерация создаёт новую переменную
- Используйте `let` в циклах для правильной работы замыканий

---

## 29. Изменяемы ли строки в JavaScript

**Нет**, строки в JavaScript **неизменяемы** (immutable). Любая операция, которая "изменяет" строку, на самом деле создаёт **новую строку**.

### Что означает неизменяемость?

Нельзя изменить символ в строке напрямую:

```js
let str = "hello";
str[0] = "H";  // не работает
console.log(str);  // "hello" (не изменилось!)
```

### Операции создают новые строки

Все методы строк возвращают **новую строку**, не изменяя исходную:

```js
let str = "hello";

let upper = str.toUpperCase();  // создаёт новую строку
console.log(str);   // "hello" (не изменилась)
console.log(upper); // "HELLO" (новая строка)

let trimmed = str.trim();       // новая строка
let replaced = str.replace("l", "L");  // новая строка
```

### Конкатенация создаёт новую строку

```js
let str = "hello";
str = str + "!";  // создаётся новая строка "hello!"
// исходная строка "hello" удаляется сборщиком мусора
```

### Почему строки неизменяемы?

Неизменяемость даёт преимущества:
1. **Безопасность** — нельзя случайно изменить строку
2. **Производительность** — строки можно переиспользовать
3. **Простые сравнения** — сравнение по значению быстрое

### Сравнение с массивами

Массивы **изменяемы**:

```js
let arr = [1, 2, 3];
arr.push(4);      // изменяет исходный массив
console.log(arr); // [1, 2, 3, 4]

let str = "hello";
str.toUpperCase(); // не изменяет исходную строку
console.log(str);  // "hello"
```

### Создание новой строки из существующей

Если нужно "изменить" строку, создайте новую:

```js
let str = "hello";
str = "H" + str.slice(1);  // создаёт новую строку "Hello"
console.log(str);  // "Hello"
```

### Итоги

- Строки неизменяемы — нельзя изменить символ напрямую
- Все операции со строками создают новые строки
- Исходная строка не изменяется
- Это обеспечивает безопасность и производительность

---

## 30. Что такое объект в JavaScript

Объект в JavaScript — это **коллекция пар "ключ-значение"**, где ключ — это строка (или Symbol), а значение — любой тип данных.

### Создание объекта

```js
// Литерал объекта
const person = {
  name: "Alex",
  age: 25,
  city: "Moscow"
};

// Через конструктор
const person2 = new Object();
person2.name = "Bob";
person2.age = 30;
```

### Структура объекта

```js
const obj = {
  key1: "value1",      // строка
  key2: 42,            // число
  key3: true,          // boolean
  key4: [1, 2, 3],     // массив
  key5: {              // вложенный объект
    nested: "value"
  },
  key6: function() {   // метод
    return "method";
  }
};
```

### Доступ к свойствам

```js
const person = { name: "Alex", age: 25 };

// Точечная нотация
person.name;  // "Alex"

// Скобочная нотация
person["name"];  // "Alex"
person["age"];   // 25

// Динамический ключ
const key = "name";
person[key];  // "Alex"
```

### Особенности объектов в JavaScript

1. **Динамические** — можно добавлять и удалять свойства:
```js
const obj = {};
obj.newProp = "новое свойство";
delete obj.newProp;
```

2. **Ссылочные** — хранятся по ссылке:
```js
const obj1 = { x: 1 };
const obj2 = obj1;  // копируется ссылка
obj2.x = 2;
console.log(obj1.x);  // 2 (изменился исходный объект!)
```

3. **Все — объекты** (почти):
   - Массивы — это объекты
   - Функции — это объекты
   - Даже примитивы имеют объекты-обёртки

### Типы значений в объектах

Ключи могут быть:
- **Строки** (автоматически, даже без кавычек)
- **Symbol** (уникальные идентификаторы)

```js
const obj = {
  "string key": "value",
  numberKey: 42,
  [Symbol("symbol")]: "symbol value"
};
```

### Методы объекта

Метод — это функция, хранящаяся как свойство объекта:

```js
const calculator = {
  x: 10,
  y: 5,
  add() {
    return this.x + this.y;
  },
  multiply() {
    return this.x * this.y;
  }
};

calculator.add();      // 15
calculator.multiply(); // 50
```

### Итоги

- Объект — коллекция пар "ключ-значение"
- Свойства могут быть любого типа
- Объекты динамические и ссылочные
- Массивы и функции — тоже объекты

---

## 31. Как проверить, что значение — массив

В JavaScript массивы технически являются объектами, поэтому обычная проверка `typeof` не работает. Нужны специальные методы.

### ❌ Неправильные способы

```js
const arr = [1, 2, 3];

typeof arr        // "object" ❌ (не подходит)
arr instanceof Array  // true ✅ (работает, но есть нюансы)
```

**Проблема с `instanceof`:**
- Не работает через iframe (разные контексты)
- Может быть переопределено

### ✅ Правильный способ: `Array.isArray()`

**Рекомендуемый способ** — использовать `Array.isArray()`:

```js
Array.isArray([1, 2, 3]);      // true ✅
Array.isArray({});             // false ✅
Array.isArray("string");       // false ✅
Array.isArray(null);           // false ✅
Array.isArray(undefined);      // false ✅
Array.isArray([]);             // true ✅
```

### Почему `Array.isArray()` лучше?

1. **Надёжно** — работает везде, даже через iframe
2. **Быстро** — оптимизированная встроенная функция
3. **Понятно** — явно показывает намерение

### Альтернативные способы (не рекомендуются)

```js
// Через Object.prototype.toString
Object.prototype.toString.call([1, 2, 3]) === '[object Array]'  // true

// Через конструктор (ненадёжно)
[1, 2, 3].constructor === Array  // true (но можно обмануть)
```

### Пример использования

```js
function processData(data) {
  if (Array.isArray(data)) {
    // обрабатываем как массив
    return data.map(item => item * 2);
  } else {
    // обрабатываем как объект
    return { processed: data };
  }
}

processData([1, 2, 3]);  // [2, 4, 6]
processData({ x: 1 });   // { processed: { x: 1 } }
```

### Итоги

- Используйте `Array.isArray()` для проверки массивов
- `typeof` не работает (возвращает "object")
- `instanceof` работает, но менее надёжен

---

## 32. Как проверить наличие свойства в объекте

В JavaScript есть несколько способов проверить, есть ли свойство в объекте. Каждый имеет свои особенности.

### Способ 1: Оператор `in`

Оператор `in` проверяет свойство **в объекте и в его прототипе**:

```js
const obj = { name: "Alex" };

"name" in obj;        // true ✅
"age" in obj;         // false ✅
"toString" in obj;    // true ⚠️ (из прототипа!)
```

### Способ 2: `hasOwnProperty()`

Метод `hasOwnProperty()` проверяет только **собственные свойства** объекта (не из прототипа):

```js
const obj = { name: "Alex" };

obj.hasOwnProperty("name");      // true ✅
obj.hasOwnProperty("age");       // false ✅
obj.hasOwnProperty("toString");  // false ✅ (не своё свойство)
```

### Способ 3: `Object.hasOwn()` (ES2022)

Современный способ, аналогичный `hasOwnProperty()`, но более безопасный:

```js
const obj = { name: "Alex" };

Object.hasOwn(obj, "name");      // true ✅
Object.hasOwn(obj, "toString");  // false ✅
```

**Преимущество:** работает даже если объект создан с `Object.create(null)`.

### Способ 4: Проверка через `undefined`

Простейший способ, но **не всегда надёжен**:

```js
const obj = { name: "Alex", age: undefined };

obj.name !== undefined;  // true ✅
obj.age !== undefined;   // false ⚠️ (но свойство есть!)
obj.city !== undefined;  // false ✅
```

**Проблема:** если свойство существует, но его значение `undefined`, проверка даст `false`.

### Сравнительная таблица

| Способ | Собственные свойства | Свойства прототипа | Значение `undefined` |
|--------|---------------------|-------------------|---------------------|
| `in` | ✅ | ✅ | ✅ |
| `hasOwnProperty()` | ✅ | ❌ | ✅ |
| `Object.hasOwn()` | ✅ | ❌ | ✅ |
| `!== undefined` | ❌ | ❌ | ❌ |

### ⚠️ Частая ошибка

```js
const obj = { name: "Alex", age: undefined };

// Неправильно
if (obj.age) {
  console.log("Есть возраст");
}  // не выполнится, т.к. undefined — falsy

// Правильно
if ("age" in obj) {
  console.log("Свойство age существует");
}  // выполнится
```

### Когда что использовать?

- **`in`** — когда нужно проверить свойство включая прототип
- **`hasOwnProperty()` / `Object.hasOwn()`** — когда нужны только собственные свойства (обычно так)
- **`!== undefined`** — когда уверены, что значение не `undefined`

### Итоги

- `in` — проверяет свойство и в объекте, и в прототипе
- `hasOwnProperty()` / `Object.hasOwn()` — только собственные свойства
- Проверка через `undefined` ненадёжна

---

## 33. Разница между `in` и `hasOwnProperty`

Это важное различие, которое часто вызывает путаницу. Давайте разберёмся подробно.

### `in` — проверяет всю цепочку прототипов

Оператор `in` проверяет свойство **во всём объекте**, включая прототип:

```js
const obj = { name: "Alex" };

"name" in obj;           // true ✅ (собственное свойство)
"toString" in obj;       // true ✅ (из прототипа Object)
"valueOf" in obj;        // true ✅ (из прототипа Object)
```

### `hasOwnProperty()` — только собственные свойства

Метод `hasOwnProperty()` проверяет только **собственные свойства** объекта, игнорируя прототип:

```js
const obj = { name: "Alex" };

obj.hasOwnProperty("name");      // true ✅ (собственное свойство)
obj.hasOwnProperty("toString");  // false ✅ (из прототипа, не собственное)
obj.hasOwnProperty("valueOf");   // false ✅ (из прототипа)
```

### Визуальная аналогия

Представьте объект как дом:
- **`in`** — ищет ключ во всём доме, включая подвал (прототип)
- **`hasOwnProperty()`** — ищет ключ только в основных комнатах (собственные свойства)

### Пример с наследованием

```js
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(this.name + " говорит");
};

const dog = new Animal("Рекс");

// in — находит и собственные, и унаследованные свойства
"name" in dog;       // true ✅ (собственное)
"speak" in dog;      // true ✅ (из прототипа)

// hasOwnProperty — только собственные
dog.hasOwnProperty("name");   // true ✅
dog.hasOwnProperty("speak");  // false ✅ (из прототипа)
```

### Когда что использовать?

**Используйте `in`, когда:**
- Нужно проверить, доступно ли свойство (включая методы прототипа)
- Проверяете существование метода

**Используйте `hasOwnProperty()` / `Object.hasOwn()`, когда:**
- Нужны только собственные свойства объекта (обычно так!)
- Итерируете по свойствам объекта
- Проверяете данные объекта, а не методы

### ⚠️ Проблема с `hasOwnProperty`

Если объект создан с `Object.create(null)`, у него нет прототипа, и `hasOwnProperty` недоступен:

```js
const obj = Object.create(null);
obj.name = "Alex";

obj.hasOwnProperty("name");  // TypeError ❌ (метода нет!)

// Решение 1: Object.hasOwn() (ES2022)
Object.hasOwn(obj, "name");  // true ✅

// Решение 2: call
Object.prototype.hasOwnProperty.call(obj, "name");  // true ✅
```

### Современная альтернатива: `Object.hasOwn()`

В ES2022 появился `Object.hasOwn()`, который решает проблему:

```js
const obj = { name: "Alex" };

Object.hasOwn(obj, "name");      // true ✅
Object.hasOwn(obj, "toString");  // false ✅

// Работает даже с Object.create(null)
const obj2 = Object.create(null);
obj2.x = 1;
Object.hasOwn(obj2, "x");  // true ✅
```

### Итоги

- `in` — проверяет свойство во всей цепочке прототипов
- `hasOwnProperty()` — только собственные свойства
- `Object.hasOwn()` — современная альтернатива `hasOwnProperty()`
- Обычно используют `hasOwnProperty()` / `Object.hasOwn()`

---

## 34. Итерация по объекту

В JavaScript есть несколько способов перебрать свойства объекта. Каждый имеет свои особенности.

### Способ 1: `for...in`

Цикл `for...in` перебирает **все перечисляемые свойства**, включая унаследованные:

```js
const obj = { name: "Alex", age: 25 };

for (let key in obj) {
  console.log(key, obj[key]);
}
// name Alex
// age 25
```

**⚠️ Важно:** перебирает и свойства прототипа! Используйте `hasOwnProperty()`:

```js
function Parent() {
  this.parentProp = "parent";
}

function Child() {
  this.childProp = "child";
}
Child.prototype = new Parent();

const obj = new Child();

for (let key in obj) {
  console.log(key);  // childProp, parentProp (оба!)
}

// Только собственные свойства
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key);  // только childProp
  }
}
```

### Способ 2: `Object.keys()`

`Object.keys()` возвращает **массив ключей** только собственных перечисляемых свойств:

```js
const obj = { name: "Alex", age: 25 };

Object.keys(obj);  // ["name", "age"]

Object.keys(obj).forEach(key => {
  console.log(key, obj[key]);
});
```

**Преимущества:**
- Только собственные свойства (не из прототипа)
- Можно использовать методы массивов (`map`, `filter`)

### Способ 3: `Object.values()`

`Object.values()` возвращает **массив значений** собственных перечисляемых свойств:

```js
const obj = { name: "Alex", age: 25 };

Object.values(obj);  // ["Alex", 25]

Object.values(obj).forEach(value => {
  console.log(value);
});
```

### Способ 4: `Object.entries()`

`Object.entries()` возвращает **массив пар [ключ, значение]**:

```js
const obj = { name: "Alex", age: 25 };

Object.entries(obj);  // [["name", "Alex"], ["age", 25]]

Object.entries(obj).forEach(([key, value]) => {
  console.log(key, value);
});

// Преобразование в Map
const map = new Map(Object.entries(obj));
```

### Сравнительная таблица

| Метод | Что возвращает | Собственные свойства | Унаследованные |
|-------|---------------|---------------------|----------------|
| `for...in` | ключи (итерация) | ✅ | ✅ |
| `Object.keys()` | массив ключей | ✅ | ❌ |
| `Object.values()` | массив значений | ✅ | ❌ |
| `Object.entries()` | массив [key, value] | ✅ | ❌ |

### Примеры использования

```js
const user = { name: "Alex", age: 25, city: "Moscow" };

// for...in
for (let key in user) {
  if (user.hasOwnProperty(key)) {
    console.log(`${key}: ${user[key]}`);
  }
}

// Object.keys() с map
const keys = Object.keys(user);
keys.map(key => `${key}: ${user[key]}`);

// Object.entries() с деструктуризацией
Object.entries(user).forEach(([key, value]) => {
  console.log(`${key}: ${value}`);
});

// Фильтрация
Object.entries(user)
  .filter(([key, value]) => typeof value === "string")
  .forEach(([key, value]) => console.log(key, value));
```

### Перечисляемые свойства

Все эти методы работают только с **перечисляемыми свойствами**. Неперечисляемые свойства (например, `length` у массивов) не попадут в перебор:

```js
const arr = [1, 2, 3];

Object.keys(arr);        // ["0", "1", "2"] (length не попадает)
Object.getOwnPropertyNames(arr);  // ["0", "1", "2", "length"] (все свойства)
```

### Итоги

- `for...in` — перебирает все свойства (включая прототип)
- `Object.keys()` — массив ключей собственных свойств
- `Object.values()` — массив значений
- `Object.entries()` — массив пар [ключ, значение]
- Обычно используют `Object.keys()` или `Object.entries()`

---

## 35. Почему `{}` !== `{}` и как сравниваются объекты

Это один из самых частых вопросов на собеседованиях. Давайте разберёмся, почему объекты сравниваются именно так.

### Объекты сравниваются по ссылке

В JavaScript объекты сравниваются **по ссылке**, а не по содержимому:

```js
{} !== {}        // true (разные объекты в памяти)
[] !== []        // true (разные массивы)
```

**Почему?** Каждый объект создаётся в **новом месте памяти**, даже если содержимое одинаковое.

### Визуальная аналогия

Представьте два одинаковых дома:
- **Примитивы** (`5 === 5`) — сравниваем сами дома (значения)
- **Объекты** (`{} !== {}`) — сравниваем адреса домов (ссылки), а не сами дома

### Примеры

```js
const obj1 = { name: "Alex" };
const obj2 = { name: "Alex" };

obj1 === obj2;  // false ❌ (разные объекты)

const obj3 = obj1;
obj1 === obj3;  // true ✅ (один и тот же объект)

obj1.name = "Bob";
console.log(obj3.name);  // "Bob" (изменился, т.к. это тот же объект)
```

### Массивы тоже объекты

```js
[1, 2, 3] === [1, 2, 3];  // false ❌

const arr1 = [1, 2, 3];
const arr2 = arr1;
arr1 === arr2;  // true ✅
```

### Функции тоже объекты

```js
function fn() {}
function fn2() {}

fn === fn2;  // false ❌

const fn3 = fn;
fn === fn3;  // true ✅
```

### Как сравнить объекты по содержимому?

JavaScript **не имеет встроенного способа** глубокого сравнения объектов. Нужно сравнивать вручную:

#### Простое сравнение (поверхностное)

```js
function shallowEqual(obj1, obj2) {
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  
  if (keys1.length !== keys2.length) {
    return false;
  }
  
  for (let key of keys1) {
    if (obj1[key] !== obj2[key]) {
      return false;
    }
  }
  
  return true;
}

shallowEqual({ a: 1 }, { a: 1 });        // true ✅
shallowEqual({ a: 1, b: { c: 2 } }, { a: 1, b: { c: 2 } });  // false ⚠️ (вложенные объекты!)
```

#### Глубокое сравнение (сложное)

Для глубокого сравнения обычно используют библиотеки (например, Lodash):

```js
// С Lodash
import _ from 'lodash';
_.isEqual({ a: { b: 1 } }, { a: { b: 1 } });  // true
```

Или реализуют рекурсивную функцию (довольно сложно).

### Сравнение примитивов

Для сравнения всё работает как ожидается:

```js
5 === 5              // true ✅
"hello" === "hello"  // true ✅
true === true        // true ✅
null === null        // true ✅
undefined === undefined  // true ✅
```

### Почему так сделано?

Сравнение по ссылке **быстрее**, чем сравнение по содержимому. Если бы объекты сравнивались по содержимому, пришлось бы проверять все свойства, включая вложенные.

### ⚠️ Частая ошибка

```js
function createUser(name) {
  return { name };
}

const user1 = createUser("Alex");
const user2 = createUser("Alex");

if (user1 === user2) {  // false ❌
  console.log("Один пользователь");
} else {
  console.log("Разные пользователи");  // выполнится
}

// Правильно — сравнивать по значению
if (user1.name === user2.name) {  // true ✅
  console.log("Одинаковые имена");
}
```

### Итоги

- Объекты сравниваются по ссылке, а не по содержимому
- `{} !== {}` потому что это разные объекты в памяти
- Для сравнения по содержимому нужна специальная функция
- Примитивы сравниваются по значению

---

## 36. Что такое прототип

Прототип (prototype) — это **механизм наследования** в JavaScript. Каждый объект имеет ссылку на другой объект — свой прототип.

### Простыми словами

Прототип — это "запасной объект", где JavaScript ищет свойства, если их нет в самом объекте.

### Как это работает?

```js
const obj = {};
obj.toString();  // "[object Object]" — откуда взялся метод toString?

// toString находится в прототипе Object.prototype
```

Когда вы обращаетесь к свойству объекта:
1. JavaScript сначала ищет свойство **в самом объекте**
2. Если не находит — идёт в **прототип объекта**
3. Если не находит — идёт в прототип прототипа (цепочка прототипов)
4. И так до `null`

### Визуальная аналогия

Представьте библиотеку:
- **Объект** — ваша полка с книгами
- **Прототип** — общая библиотека
- Если книги нет на вашей полке, идёте в общую библиотеку

### Пример с конструктором

```js
function User(name) {
  this.name = name;
}

// Добавляем метод в прототип
User.prototype.sayHi = function() {
  console.log(`Привет, я ${this.name}`);
};

const user1 = new User("Alex");
const user2 = new User("Bob");

user1.sayHi();  // "Привет, я Alex"
user2.sayHi();  // "Привет, я Bob"

// Метод sayHi один для всех экземпляров!
user1.sayHi === user2.sayHi;  // true ✅
```

**Почему методы в прототипе?** Чтобы все экземпляры использовали **один и тот же метод**, а не копию.

### Доступ к прототипу

```js
const obj = {};

// Старый способ (не рекомендуется)
obj.__proto__  // Object.prototype

// Современный способ
Object.getPrototypeOf(obj);  // Object.prototype
```

### Установка прототипа

```js
const animal = { type: "animal" };
const dog = { name: "Rex" };

// Старый способ (не рекомендуется)
dog.__proto__ = animal;

// Современный способ
Object.setPrototypeOf(dog, animal);

// Или при создании
const dog2 = Object.create(animal);
dog2.name = "Rex";
```

### Зачем нужны прототипы?

1. **Наследование** — объекты могут наследовать свойства и методы
2. **Экономия памяти** — методы хранятся один раз, а не в каждом объекте
3. **Динамичность** — можно добавлять методы в прототип, и все объекты их получат

### Итоги

- Прототип — механизм наследования в JavaScript
- Если свойства нет в объекте, поиск идёт в прототипе
- Методы обычно хранят в прототипе
- Используйте `Object.getPrototypeOf()` вместо `__proto__`

---

## 37. `__proto__`, `[[Prototype]]`, `Object.getPrototypeOf`

Это три способа работы с прототипом объекта. Давайте разберёмся в их различиях.

### `[[Prototype]]` — внутреннее свойство

`[[Prototype]]` — это **внутреннее (скрытое) свойство** объекта, которое хранит ссылку на прототип. К нему **нельзя обратиться напрямую** в коде.

Это часть спецификации ECMAScript.

### `__proto__` — устаревший способ доступа

`__proto__` — это **геттер/сеттер** для доступа к `[[Prototype]]`. Это **устаревший способ**, который:

- Работает, но не рекомендуется
- Может быть медленнее
- Не всегда доступен (например, `Object.create(null)`)

```js
const obj = {};

obj.__proto__;                    // Object.prototype (устаревший способ)
obj.__proto__ === Object.prototype;  // true
```

### `Object.getPrototypeOf()` — современный способ

`Object.getPrototypeOf()` — **рекомендуемый способ** получить прототип:

```js
const obj = {};

Object.getPrototypeOf(obj);                    // Object.prototype ✅
Object.getPrototypeOf(obj) === Object.prototype;  // true ✅
```

**Преимущества:**
- Работает везде
- Более явный и понятный
- Рекомендуется стандартом

### Сравнение способов

```js
const obj = {};

// Все три способа дают один результат
obj.__proto__ === Object.getPrototypeOf(obj);  // true
Object.getPrototypeOf(obj) === Object.prototype;  // true
```

### Установка прототипа

#### `__proto__` (не рекомендуется)

```js
const parent = { x: 1 };
const child = {};

child.__proto__ = parent;  // ⚠️ устаревший способ
console.log(child.x);      // 1
```

#### `Object.setPrototypeOf()` (рекомендуется)

```js
const parent = { x: 1 };
const child = {};

Object.setPrototypeOf(child, parent);  // ✅ современный способ
console.log(child.x);  // 1
```

#### `Object.create()` (лучший способ при создании)

```js
const parent = { x: 1 };
const child = Object.create(parent);  // ✅ создаёт объект с прототипом

console.log(child.x);  // 1
```

### Когда что использовать?

- **`[[Prototype]]`** — это внутреннее свойство, к нему нельзя обратиться
- **`__proto__`** — избегайте, устаревший способ
- **`Object.getPrototypeOf()`** — используйте для получения прототипа
- **`Object.setPrototypeOf()`** — используйте для установки прототипа
- **`Object.create()`** — используйте при создании объекта с прототипом

### ⚠️ Важно

Изменение прототипа **медленная операция** и может влиять на производительность:

```js
// Медленно ❌
Object.setPrototypeOf(obj, newProto);

// Быстро ✅
const obj = Object.create(newProto);
```

### Итоги

- `[[Prototype]]` — внутреннее свойство, недоступно напрямую
- `__proto__` — устаревший способ доступа
- `Object.getPrototypeOf()` — рекомендуемый способ получения прототипа
- `Object.setPrototypeOf()` — для установки прототипа
- `Object.create()` — лучший способ при создании объекта

---

## 38. Цепочка прототипов

Цепочка прототипов (prototype chain) — это путь, по которому JavaScript ищет свойства объекта, переходя от объекта к прототипу, затем к прототипу прототипа и так далее.

### Как это работает?

Когда вы обращаетесь к свойству объекта, JavaScript:

1. Ищет свойство **в самом объекте**
2. Если не находит — идёт в **прототип объекта**
3. Если не находит — идёт в **прототип прототипа**
4. Продолжает до конца цепочки
5. Если не находит — возвращает `undefined`

### Пример цепочки

```js
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(this.name + " ест");
};

function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  console.log(this.name + " лает");
};

const rex = new Dog("Rex", "Labrador");

// Цепочка прототипов:
// rex → Dog.prototype → Animal.prototype → Object.prototype → null

rex.bark();   // "Rex лает" (из Dog.prototype)
rex.eat();    // "Rex ест" (из Animal.prototype)
rex.toString();  // "[object Object]" (из Object.prototype)
```

### Визуализация цепочки

```
rex (объект)
  ↓ __proto__
Dog.prototype
  ↓ __proto__
Animal.prototype
  ↓ __proto__
Object.prototype
  ↓ __proto__
null
```

### Поиск свойства

```js
const obj = { x: 1 };

// Поиск свойства y:
// 1. obj — нет y
// 2. Object.prototype — нет y
// 3. null — конец цепочки
// Результат: undefined

console.log(obj.y);  // undefined
```

### Собственные vs унаследованные свойства

```js
function Parent() {
  this.own = "собственное";
}

Parent.prototype.inherited = "унаследованное";

const child = new Parent();

console.log(child.own);        // "собственное" (своё свойство)
console.log(child.inherited);  // "унаследованное" (из прототипа)

child.hasOwnProperty("own");        // true ✅
child.hasOwnProperty("inherited");  // false ✅ (из прототипа)
```

### Переопределение свойства

Если свойство есть и в объекте, и в прототипе, используется **собственное**:

```js
function Parent() {}
Parent.prototype.value = "прототип";

const child = new Parent();
child.value = "собственное";

console.log(child.value);  // "собственное" (переопределило)
```

### Зачем нужна цепочка прототипов?

1. **Наследование** — объекты наследуют свойства и методы
2. **Экономия памяти** — методы хранятся один раз
3. **Гибкость** — можно добавлять методы в прототип

### Итоги

- Цепочка прототипов — путь поиска свойств от объекта до null
- JavaScript ищет свойства по цепочке снизу вверх
- Собственные свойства имеют приоритет
- Цепочка заканчивается на `null`

---

## 39. Что находится в конце цепочки прототипов

В конце цепочки прототипов всегда находится **`null`**.

### Структура цепочки

Цепочка прототипов всегда заканчивается на `null`:

```js
const obj = {};

// Цепочка:
// obj → Object.prototype → null

Object.getPrototypeOf(obj) === Object.prototype;  // true
Object.getPrototypeOf(Object.prototype) === null;  // true ✅
```

### Проверка конца цепочки

```js
function getPrototypeChain(obj) {
  const chain = [];
  let current = obj;
  
  while (current !== null) {
    chain.push(current);
    current = Object.getPrototypeOf(current);
  }
  
  return chain;
}

const obj = {};
const chain = getPrototypeChain(obj);
// [obj, Object.prototype]
// null — конец цепочки
```

### Почему `null`?

`null` используется как маркер **конца цепочки**. Когда JavaScript доходит до `null`, он понимает, что свойство не найдено, и возвращает `undefined`.

### Пример для разных объектов

```js
// Обычный объект
const obj = {};
// obj → Object.prototype → null

// Массив
const arr = [];
// arr → Array.prototype → Object.prototype → null

// Функция
function fn() {}
// fn → Function.prototype → Object.prototype → null

// Строка (при использовании как объект)
const str = "hello";
// str (примитив) → String.prototype → Object.prototype → null
```

### `Object.prototype` — последний реальный объект

`Object.prototype` — это **последний объект** в цепочке, его прототип — `null`:

```js
Object.getPrototypeOf(Object.prototype);  // null ✅
Object.prototype.__proto__;               // null ✅
```

### Что в `Object.prototype`?

`Object.prototype` содержит базовые методы для всех объектов:

```js
Object.prototype.toString;    // метод toString
Object.prototype.valueOf;     // метод valueOf
Object.prototype.hasOwnProperty;  // метод hasOwnProperty
// и другие...
```

### Итоги

- В конце цепочки прототипов всегда `null`
- `Object.prototype` — последний объект (его прототип — `null`)
- `null` — маркер конца цепочки
- Когда JavaScript доходит до `null`, возвращает `undefined`

---

## 40. Поверхностное и глубокое копирование

При копировании объектов важно понимать разницу между поверхностным и глубоким копированием.

### Поверхностное копирование (Shallow Copy)

Поверхностное копирование создаёт новый объект и копирует только **первый уровень** свойств. Вложенные объекты **не копируются**, а передаются по ссылке.

```js
const original = {
  name: "Alex",
  age: 25,
  address: {
    city: "Moscow",
    street: "Lenin St"
  }
};

// Поверхностная копия
const shallow = Object.assign({}, original);
// или
const shallow2 = { ...original };

shallow.name = "Bob";
shallow.address.city = "SPB";

console.log(original.name);        // "Alex" ✅ (не изменилось)
console.log(original.address.city);  // "SPB" ⚠️ (изменилось!)
```

**Проблема:** изменения во вложенных объектах влияют на оригинал.

### Глубокое копирование (Deep Copy)

Глубокое копирование создаёт **полностью независимую копию** со всеми вложенными объектами.

```js
const original = {
  name: "Alex",
  address: {
    city: "Moscow"
  }
};

// Глубокая копия
const deep = structuredClone(original);  // современный способ

deep.address.city = "SPB";

console.log(original.address.city);  // "Moscow" ✅ (не изменилось!)
console.log(deep.address.city);      // "SPB" ✅
```

### Визуальная аналогия

- **Поверхностное** — как ксерокопия первой страницы документа, остальные страницы — ссылки на оригинал
- **Глубокое** — как полная ксерокопия всего документа со всеми страницами

### Способы поверхностного копирования

```js
const obj = { a: 1, b: { c: 2 } };

// 1. Object.assign
const copy1 = Object.assign({}, obj);

// 2. Spread operator
const copy2 = { ...obj };

// 3. Array.from (для массивов)
const arr = [1, 2, { x: 3 }];
const copy3 = Array.from(arr);
// или
const copy4 = [...arr];
```

### Способы глубокого копирования

#### 1. `structuredClone()` (ES2022, рекомендуемый)

```js
const obj = { a: 1, b: { c: 2 } };
const deep = structuredClone(obj);
```

**Преимущества:**
- Простой синтаксис
- Копирует большинство типов данных
- Работает с циклическими ссылками

**Ограничения:**
- Не копирует функции
- Не копирует Symbol

#### 2. `JSON.parse(JSON.stringify())`

```js
const obj = { a: 1, b: { c: 2 } };
const deep = JSON.parse(JSON.stringify(obj));
```

**Ограничения:**
- Не копирует функции
- Не копирует `undefined`
- Не копирует Symbol
- Не копирует Date (превращает в строку)
- Не работает с циклическими ссылками

#### 3. Рекурсивная функция (для сложных случаев)

```js
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  if (obj instanceof Array) {
    return obj.map(item => deepClone(item));
  }
  
  const cloned = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key]);
    }
  }
  
  return cloned;
}
```

### Когда что использовать?

- **Поверхностное копирование** — когда нет вложенных объектов или они не должны изменяться
- **Глубокое копирование** — когда нужна полностью независимая копия со всеми вложенными объектами

### ⚠️ Частая ошибка

```js
const original = { a: 1, b: { c: 2 } };

// Кажется, что это глубокая копия, но это поверхностная!
const copy = { ...original };
copy.b.c = 3;

console.log(original.b.c);  // 3 ⚠️ (изменился!)
```

### Итоги

- Поверхностное копирование — только первый уровень, вложенные объекты по ссылке
- Глубокое копирование — полностью независимая копия
- Используйте `structuredClone()` для глубокого копирования
- Spread и Object.assign — поверхностное копирование

---

## 41. Способы копирования объектов

В JavaScript есть несколько способов копирования объектов. Выбор зависит от того, нужна ли вам поверхностная или глубокая копия.

### Поверхностное копирование

#### 1. Spread operator (`...`)

Самый популярный и читаемый способ:

```js
const obj = { name: "Alex", age: 25 };
const copy = { ...obj };

copy.name = "Bob";
console.log(obj.name);  // "Alex" ✅ (не изменилось)
```

#### 2. `Object.assign()`

Создаёт поверхностную копию:

```js
const obj = { name: "Alex", age: 25 };
const copy = Object.assign({}, obj);

// Можно объединить несколько объектов
const merged = Object.assign({}, obj1, obj2, obj3);
```

#### 3. `Array.from()` / Spread для массивов

```js
const arr = [1, 2, 3];
const copy1 = Array.from(arr);
const copy2 = [...arr];
```

### Глубокое копирование

#### 1. `structuredClone()` (ES2022, рекомендуемый)

```js
const obj = { a: 1, b: { c: 2 } };
const deep = structuredClone(obj);
```

#### 2. `JSON.parse(JSON.stringify())`

```js
const obj = { a: 1, b: { c: 2 } };
const deep = JSON.parse(JSON.stringify(obj));
```

**⚠️ Ограничения:** не копирует функции, `undefined`, Symbol, Date (см. тему 43).

#### 3. Рекурсивная функция

Для сложных случаев с функциями и другими типами данных.

### Сравнительная таблица

| Способ | Тип копирования | Скорость | Ограничения |
|--------|----------------|----------|-------------|
| `{ ...obj }` | Поверхностная | Быстро | Вложенные объекты по ссылке |
| `Object.assign()` | Поверхностная | Быстро | Вложенные объекты по ссылке |
| `structuredClone()` | Глубокая | Средне | Не копирует функции, Symbol |
| `JSON.parse(JSON.stringify())` | Глубокая | Медленно | Много ограничений (см. тему 43) |

### Когда что использовать?

- **Spread / Object.assign** — когда нет вложенных объектов или они не должны изменяться
- **structuredClone()** — когда нужна глубокая копия (большинство случаев)
- **JSON способ** — только для простых данных без функций

### Итоги

- Поверхностное: spread, Object.assign
- Глубокое: structuredClone(), JSON способ
- Выбор зависит от структуры данных

---

## 42. Как сделать глубокую копию объекта

Глубокая копия нужна, когда нужно создать полностью независимую копию объекта со всеми вложенными объектами.

### Способ 1: `structuredClone()` (рекомендуемый, ES2022)

Самый простой и современный способ:

```js
const original = {
  name: "Alex",
  address: {
    city: "Moscow",
    street: "Lenin St"
  },
  hobbies: ["reading", "coding"]
};

const deep = structuredClone(original);

deep.address.city = "SPB";
deep.hobbies.push("gaming");

console.log(original.address.city);  // "Moscow" ✅
console.log(original.hobbies);       // ["reading", "coding"] ✅
```

**Что копирует:**
- Объекты и массивы
- Примитивы
- Date (как Date объект)
- RegExp
- Map, Set
- Циклические ссылки

**Что НЕ копирует:**
- Функции
- Symbol

### Способ 2: `JSON.parse(JSON.stringify())`

Работает, но с ограничениями:

```js
const original = { a: 1, b: { c: 2 } };
const deep = JSON.parse(JSON.stringify(original));
```

**Проблемы:**
- Функции теряются
- `undefined` теряется
- Symbol теряется
- Date превращается в строку
- Не работает с циклическими ссылками

### Способ 3: Рекурсивная функция

Для случаев, когда нужны функции или другие особые типы:

```js
function deepClone(obj) {
  // Примитивы и null
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  
  // Date
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  
  // Массивы
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item));
  }
  
  // Объекты
  const cloned = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key]);
    }
  }
  
  return cloned;
}

const original = {
  name: "Alex",
  date: new Date(),
  arr: [1, { x: 2 }]
};

const deep = deepClone(original);
```

### Способ 4: Библиотеки (Lodash)

Для продакшена часто используют библиотеки:

```js
import _ from 'lodash';

const deep = _.cloneDeep(original);
```

### Сравнение способов

```js
const obj = {
  a: 1,
  b: { c: 2 },
  fn: function() {},
  date: new Date(),
  sym: Symbol("test"),
  undef: undefined
};

// structuredClone
const clone1 = structuredClone(obj);
// Результат: a, b, date ✅ (но нет fn, sym, undef)

// JSON способ
const clone2 = JSON.parse(JSON.stringify(obj));
// Результат: только a, b ✅ (date → строка, остальное потеряно)

// Рекурсивная функция
const clone3 = deepClone(obj);
// Результат: все кроме Symbol (нужно добавить обработку)
```

### ⚠️ Частая ошибка

Попытка сделать глубокую копию через spread:

```js
const original = { a: { b: 1 } };
const copy = { ...original };  // поверхностная копия!

copy.a.b = 2;
console.log(original.a.b);  // 2 ⚠️ (изменилось!)
```

### Итоги

- `structuredClone()` — лучший современный способ
- JSON способ — только для простых данных
- Рекурсивная функция — для особых случаев
- Библиотеки — для сложных проектов

---

## 43. Ограничения `JSON.parse(JSON.stringify())`

Метод `JSON.parse(JSON.stringify())` — простой способ глубокого копирования, но у него много ограничений. Важно их знать!

### Что работает

```js
const obj = {
  name: "Alex",
  age: 25,
  nested: { x: 1 },
  arr: [1, 2, 3]
};

const copy = JSON.parse(JSON.stringify(obj));
// ✅ Копирует: объекты, массивы, примитивы (string, number, boolean, null)
```

### Ограничение 1: Функции теряются

```js
const obj = {
  name: "Alex",
  greet: function() {
    return "Hello";
  }
};

const copy = JSON.parse(JSON.stringify(obj));
console.log(copy.greet);  // undefined ❌ (функция потеряна!)
```

### Ограничение 2: `undefined` теряется

```js
const obj = {
  name: "Alex",
  age: undefined
};

const copy = JSON.parse(JSON.stringify(obj));
console.log(copy.age);  // undefined (но свойство отсутствует!)
console.log("age" in copy);  // false ❌ (свойство удалено!)
```

### Ограничение 3: Symbol теряется

```js
const sym = Symbol("test");
const obj = {
  name: "Alex",
  [sym]: "value"
};

const copy = JSON.parse(JSON.stringify(obj));
console.log(copy[sym]);  // undefined ❌ (Symbol потерян!)
```

### Ограничение 4: Date превращается в строку

```js
const obj = {
  name: "Alex",
  date: new Date()
};

const copy = JSON.parse(JSON.stringify(obj));
console.log(copy.date);  // "2024-01-01T00:00:00.000Z" ❌ (строка, не Date!)
console.log(copy.date instanceof Date);  // false
```

### Ограничение 5: Циклические ссылки вызывают ошибку

```js
const obj = { name: "Alex" };
obj.self = obj;  // циклическая ссылка

JSON.parse(JSON.stringify(obj));  // TypeError ❌ (не может сериализовать!)
```

### Ограничение 6: `NaN`, `Infinity`, `-Infinity` превращаются в `null`

```js
const obj = {
  a: NaN,
  b: Infinity,
  c: -Infinity
};

const copy = JSON.parse(JSON.stringify(obj));
console.log(copy.a);  // null ❌
console.log(copy.b);  // null ❌
console.log(copy.c);  // null ❌
```

### Ограничение 7: Map и Set теряются

```js
const obj = {
  map: new Map([["key", "value"]]),
  set: new Set([1, 2, 3])
};

const copy = JSON.parse(JSON.stringify(obj));
console.log(copy.map);  // {} ❌ (пустой объект)
console.log(copy.set);  // {} ❌ (пустой объект)
```

### Когда использовать?

Используйте `JSON.parse(JSON.stringify())` только если:
- ✅ Нет функций
- ✅ Нет `undefined` (или не важно)
- ✅ Нет Symbol
- ✅ Нет Date (или можно преобразовать)
- ✅ Нет циклических ссылок
- ✅ Только простые данные (объекты, массивы, примитивы)

### Альтернатива: `structuredClone()`

Для большинства случаев лучше использовать `structuredClone()`:

```js
const obj = {
  date: new Date(),
  map: new Map([["key", "value"]]),
  nested: { x: 1 }
};

const copy = structuredClone(obj);  // ✅ Работает лучше!
```

### Итоги

- `JSON.parse(JSON.stringify())` имеет много ограничений
- Не работает с функциями, `undefined`, Symbol, Date, циклическими ссылками
- Используйте только для простых данных
- Для сложных случаев — `structuredClone()` или библиотеки

---

## 44. Какие типы данных теряются при `JSON.stringify`

`JSON.stringify()` может сериализовать только ограниченный набор типов данных. Всё остальное теряется или преобразуется.

### Что сохраняется

```js
const obj = {
  string: "text",
  number: 42,
  boolean: true,
  null: null,
  array: [1, 2, 3],
  object: { nested: "value" }
};

JSON.stringify(obj);
// ✅ Все эти типы сохраняются
```

### Что теряется или преобразуется

#### 1. `undefined` — полностью удаляется

```js
const obj = { a: 1, b: undefined };
JSON.stringify(obj);  // '{"a":1}' ❌ (b удалено!)
```

#### 2. Функции — удаляются

```js
const obj = { a: 1, fn: function() {} };
JSON.stringify(obj);  // '{"a":1}' ❌ (fn удалено!)
```

#### 3. Symbol — удаляется

```js
const sym = Symbol("test");
const obj = { a: 1, [sym]: "value" };
JSON.stringify(obj);  // '{"a":1}' ❌ (Symbol удалён!)
```

#### 4. Date — превращается в строку

```js
const obj = { date: new Date() };
JSON.stringify(obj);
// '{"date":"2024-01-01T00:00:00.000Z"}' ❌ (строка, не Date!)
```

#### 5. `NaN`, `Infinity`, `-Infinity` — превращаются в `null`

```js
const obj = { a: NaN, b: Infinity, c: -Infinity };
JSON.stringify(obj);
// '{"a":null,"b":null,"c":null}' ❌
```

#### 6. Map, Set — становятся пустыми объектами

```js
const obj = {
  map: new Map([["key", "value"]]),
  set: new Set([1, 2, 3])
};

JSON.stringify(obj);
// '{"map":{},"set":{}}' ❌ (пустые объекты!)
```

#### 7. RegExp — становится пустым объектом

```js
const obj = { regex: /test/gi };
JSON.stringify(obj);
// '{"regex":{}}' ❌
```

#### 8. Циклические ссылки — ошибка

```js
const obj = { name: "Alex" };
obj.self = obj;

JSON.stringify(obj);  // TypeError ❌ (не может сериализовать!)
```

### Таблица потери данных

| Тип данных | Что происходит |
|-----------|----------------|
| `string`, `number`, `boolean` | ✅ Сохраняется |
| `null` | ✅ Сохраняется |
| `Array`, `Object` | ✅ Сохраняется |
| `undefined` | ❌ Удаляется |
| `Function` | ❌ Удаляется |
| `Symbol` | ❌ Удаляется |
| `Date` | ❌ Превращается в строку |
| `NaN`, `Infinity` | ❌ Превращается в `null` |
| `Map`, `Set` | ❌ Пустой объект `{}` |
| `RegExp` | ❌ Пустой объект `{}` |
| Циклические ссылки | ❌ Ошибка |

### Как сохранить Date?

Можно использовать `replacer` функцию:

```js
const obj = { date: new Date() };

JSON.stringify(obj, (key, value) => {
  if (value instanceof Date) {
    return value.toISOString();  // или value.getTime()
  }
  return value;
});
```

Но при `JSON.parse()` это всё равно будет строка, не Date.

### Итоги

- `JSON.stringify()` сохраняет только: объекты, массивы, примитивы
- Теряет: функции, `undefined`, Symbol
- Преобразует: Date → строка, NaN/Infinity → null, Map/Set → {}
- Для сохранения всех типов используйте `structuredClone()` или библиотеки

---

## 45. Мутация и иммутабельность

Мутация и иммутабельность — важные концепции в программировании, особенно в функциональном программировании и современных фреймворках.

### Что такое мутация?

**Мутация** (mutation) — это изменение существующего объекта или массива.

```js
const obj = { name: "Alex" };
obj.name = "Bob";  // мутация — изменён существующий объект

const arr = [1, 2, 3];
arr.push(4);  // мутация — изменён существующий массив
```

### Что такое иммутабельность?

**Иммутабельность** (immutability) — создание нового объекта/массива вместо изменения существующего.

```js
const obj = { name: "Alex" };
const newObj = { ...obj, name: "Bob" };  // новый объект

const arr = [1, 2, 3];
const newArr = [...arr, 4];  // новый массив
```

### Примитивы — неизменяемы

Примитивы в JavaScript **всегда неизменяемы**:

```js
let str = "hello";
str.toUpperCase();  // создаёт новую строку
console.log(str);   // "hello" ✅ (не изменилась)

let num = 5;
num = 6;  // это не мутация! Переменная получила новое значение
```

### Объекты и массивы — изменяемы

Объекты и массивы **изменяемы по умолчанию**:

```js
const obj = { count: 0 };
obj.count = 1;  // мутация ✅

const arr = [1, 2];
arr.push(3);  // мутация ✅
```

### Почему важна иммутабельность?

1. **Предсказуемость** — данные не изменяются неожиданно
2. **Отладка** — проще отслеживать изменения
3. **Реактивность** — фреймворки (React, Vue) отслеживают изменения через сравнение ссылок
4. **Параллелизм** — безопасность при многопоточности

### Пример проблемы с мутацией

```js
const original = { name: "Alex", age: 25 };
const copy = original;  // копия ссылки

copy.age = 30;  // мутация
console.log(original.age);  // 30 ⚠️ (изменился оригинал!)
```

### Иммутабельное обновление

```js
const original = { name: "Alex", age: 25 };
const updated = { ...original, age: 30 };  // новый объект

console.log(original.age);  // 25 ✅ (не изменился)
console.log(updated.age);   // 30 ✅
```

### Иммутабельная работа с массивами

#### Вместо мутации:

```js
// ❌ Мутация
const arr = [1, 2, 3];
arr.push(4);
arr.pop();
arr.sort();

// ✅ Иммутабельно
const arr = [1, 2, 3];
const withFour = [...arr, 4];  // новый массив
const withoutLast = arr.slice(0, -1);  // новый массив
const sorted = [...arr].sort();  // новый массив
```

### Иммутабельные методы массивов

Методы, которые **не изменяют** исходный массив (возвращают новый):

```js
const arr = [1, 2, 3];

arr.map(x => x * 2);      // [2, 4, 6] ✅ (новый массив)
arr.filter(x => x > 1);   // [2, 3] ✅ (новый массив)
arr.slice(0, 2);          // [1, 2] ✅ (новый массив)
arr.concat([4]);          // [1, 2, 3, 4] ✅ (новый массив)
```

### Мутирующие методы массивов

Методы, которые **изменяют** исходный массив:

```js
const arr = [1, 2, 3];

arr.push(4);    // изменяет arr ❌
arr.pop();      // изменяет arr ❌
arr.sort();     // изменяет arr ❌
arr.reverse();  // изменяет arr ❌
```

### Итоги

- Мутация — изменение существующего объекта/массива
- Иммутабельность — создание нового объекта/массива
- Примитивы неизменяемы, объекты изменяемы
- Иммутабельность делает код предсказуемее
- Используйте spread и немутирующие методы для иммутабельности

---

## 46. Методы массивов `map`, `filter`, `reduce`

Три самых важных метода массивов в JavaScript. Они не изменяют исходный массив и очень часто используются.

### `map` — преобразование элементов

`map` создаёт **новый массив**, применяя функцию к каждому элементу:

```js
const numbers = [1, 2, 3, 4];
const doubled = numbers.map(n => n * 2);
// [2, 4, 6, 8] ✅ (новый массив)

console.log(numbers);  // [1, 2, 3, 4] (исходный не изменился)
```

**Синтаксис:**
```js
array.map((element, index, array) => {
  // возвращает новое значение для элемента
});
```

**Примеры:**
```js
// Преобразование объектов
const users = [
  { name: "Alex", age: 25 },
  { name: "Bob", age: 30 }
];

const names = users.map(user => user.name);
// ["Alex", "Bob"]

// Преобразование типов
const strings = ["1", "2", "3"];
const numbers = strings.map(str => Number(str));
// [1, 2, 3]
```

### `filter` — фильтрация элементов

`filter` создаёт **новый массив** с элементами, прошедшими проверку:

```js
const numbers = [1, 2, 3, 4, 5];
const even = numbers.filter(n => n % 2 === 0);
// [2, 4] ✅ (только чётные)

console.log(numbers);  // [1, 2, 3, 4, 5] (исходный не изменился)
```

**Синтаксис:**
```js
array.filter((element, index, array) => {
  // возвращает true/false
  // true — элемент остаётся, false — убирается
});
```

**Примеры:**
```js
// Фильтрация по условию
const users = [
  { name: "Alex", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 20 }
];

const adults = users.filter(user => user.age >= 25);
// [{ name: "Alex", age: 25 }, { name: "Bob", age: 30 }]

// Удаление undefined/null
const values = [1, null, 2, undefined, 3];
const clean = values.filter(v => v != null);
// [1, 2, 3]
```

### `reduce` — свёртка массива в одно значение

`reduce` **сводит массив к одному значению**, применяя функцию к каждому элементу:

```js
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((acc, n) => acc + n, 0);
// 10 ✅

// Пошагово:
// acc = 0, n = 1 → acc = 1
// acc = 1, n = 2 → acc = 3
// acc = 3, n = 3 → acc = 6
// acc = 6, n = 4 → acc = 10
```

**Синтаксис:**
```js
array.reduce((accumulator, element, index, array) => {
  // возвращает новое значение аккумулятора
}, initialValue);
```

**Важно:** если не указать начальное значение, берётся первый элемент (может привести к ошибкам!).

**Примеры:**
```js
// Сумма
const sum = [1, 2, 3].reduce((acc, n) => acc + n, 0);  // 6

// Произведение
const product = [2, 3, 4].reduce((acc, n) => acc * n, 1);  // 24

// Максимум
const max = [5, 2, 8, 1].reduce((acc, n) => n > acc ? n : acc, -Infinity);  // 8

// Группировка
const items = [
  { type: "fruit", name: "apple" },
  { type: "fruit", name: "banana" },
  { type: "vegetable", name: "carrot" }
];

const grouped = items.reduce((acc, item) => {
  if (!acc[item.type]) {
    acc[item.type] = [];
  }
  acc[item.type].push(item.name);
  return acc;
}, {});
// { fruit: ["apple", "banana"], vegetable: ["carrot"] }
```

### Цепочки методов

Методы можно объединять в цепочки:

```js
const numbers = [1, 2, 3, 4, 5, 6];

const result = numbers
  .filter(n => n % 2 === 0)  // [2, 4, 6]
  .map(n => n * 2)            // [4, 8, 12]
  .reduce((acc, n) => acc + n, 0);  // 24
```

### Сравнение методов

| Метод | Что возвращает | Изменяет исходный? |
|-------|---------------|-------------------|
| `map` | Новый массив (та же длина) | ❌ Нет |
| `filter` | Новый массив (меньше или равно) | ❌ Нет |
| `reduce` | Одно значение | ❌ Нет |

### ⚠️ Частая ошибка с `reduce`

Забывают начальное значение:

```js
const numbers = [1, 2, 3];

// Без начального значения (работает, но рискованно)
const sum1 = numbers.reduce((acc, n) => acc + n);  // 6

// С начальным значением (правильно)
const sum2 = numbers.reduce((acc, n) => acc + n, 0);  // 6 ✅

// Проблема с пустым массивом
[].reduce((acc, n) => acc + n);  // TypeError ❌
[].reduce((acc, n) => acc + n, 0);  // 0 ✅
```

### Итоги

- `map` — преобразует каждый элемент (новая длина = старая)
- `filter` — отбирает элементы по условию (новая длина ≤ старая)
- `reduce` — сводит массив к одному значению
- Все три метода не изменяют исходный массив
- Можно объединять в цепочки

---

## 47. Разница между `map` и `forEach`

`map` и `forEach` похожи, но имеют важные отличия. Часто их путают новички.

### `map` — возвращает новый массив

`map` **возвращает новый массив** с преобразованными элементами:

```js
const numbers = [1, 2, 3];
const doubled = numbers.map(n => n * 2);

console.log(doubled);  // [2, 4, 6] ✅ (новый массив)
console.log(numbers);  // [1, 2, 3] (исходный не изменился)
```

### `forEach` — ничего не возвращает

`forEach` **не возвращает значение** (возвращает `undefined`):

```js
const numbers = [1, 2, 3];
const result = numbers.forEach(n => n * 2);

console.log(result);  // undefined ❌
```

### Когда использовать `map`?

Используйте `map`, когда нужно:
- ✅ Преобразовать массив
- ✅ Получить новый массив с результатами
- ✅ Объединить в цепочку методов

```js
const users = [{ name: "Alex" }, { name: "Bob" }];

const names = users.map(user => user.name);
// ["Alex", "Bob"]

// В цепочке
users
  .map(user => user.name)
  .filter(name => name.length > 3)
  .map(name => name.toUpperCase());
```

### Когда использовать `forEach`?

Используйте `forEach`, когда нужно:
- ✅ Выполнить действие для каждого элемента
- ✅ Вывести в консоль
- ✅ Изменить внешние переменные
- ✅ Вызвать функцию с побочными эффектами

```js
const numbers = [1, 2, 3];

// Вывод в консоль
numbers.forEach(n => console.log(n));

// Изменение внешней переменной
let sum = 0;
numbers.forEach(n => {
  sum += n;
});
console.log(sum);  // 6

// Побочные эффекты
numbers.forEach(n => {
  updateDatabase(n);  // действие с побочным эффектом
});
```

### Сравнительная таблица

| Особенность | `map` | `forEach` |
|-------------|-------|-----------|
| Возвращает значение | ✅ Новый массив | ❌ `undefined` |
| Изменяет исходный массив | ❌ Нет | ❌ Нет |
| Использование | Преобразование | Действия/побочные эффекты |
| Можно объединять в цепочки | ✅ Да | ❌ Нет |

### ⚠️ Частая ошибка

Попытка использовать `forEach` для преобразования:

```js
const numbers = [1, 2, 3];

// Неправильно
const doubled = numbers.forEach(n => n * 2);
console.log(doubled);  // undefined ❌

// Правильно
const doubled = numbers.map(n => n * 2);
console.log(doubled);  // [2, 4, 6] ✅
```

### Можно ли использовать `map` для побочных эффектов?

Технически да, но **не рекомендуется**:

```js
// Плохо ❌ (map для побочных эффектов)
numbers.map(n => console.log(n));

// Хорошо ✅ (forEach для побочных эффектов)
numbers.forEach(n => console.log(n));
```

**Почему?** `map` предназначен для преобразования, использование для побочных эффектов запутывает код.

### Производительность

`map` и `forEach` имеют **одинаковую производительность**. Разница незначительна.

### Итоги

- `map` — возвращает новый массив (для преобразования)
- `forEach` — ничего не возвращает (для действий)
- `map` — для получения нового массива
- `forEach` — для побочных эффектов
- Не путайте их назначение!

---

## 48. Методы массива `find`, `some`, `every`

Эти три метода помогают проверять элементы массива и находить нужные значения.

### `find` — находит первый элемент

`find` возвращает **первый элемент**, который соответствует условию:

```js
const users = [
  { id: 1, name: "Alex", age: 25 },
  { id: 2, name: "Bob", age: 30 },
  { id: 3, name: "Charlie", age: 25 }
];

const user = users.find(u => u.age === 25);
// { id: 1, name: "Alex", age: 25 } ✅ (первый найденный)

const notFound = users.find(u => u.age > 100);
// undefined ✅ (не найдено)
```

**Синтаксис:**
```js
array.find((element, index, array) => {
  // возвращает true/false
  // true — элемент найден, возвращается element
});
```

### `some` — проверяет, есть ли хотя бы один

`some` возвращает `true`, если **хотя бы один элемент** соответствует условию:

```js
const numbers = [1, 2, 3, 4, 5];

numbers.some(n => n > 3);  // true ✅ (есть элементы > 3)
numbers.some(n => n > 10); // false ✅ (нет элементов > 10)
```

**Синтаксис:**
```js
array.some((element, index, array) => {
  // возвращает true/false
});
```

**Примеры:**
```js
const users = [
  { name: "Alex", active: true },
  { name: "Bob", active: false },
  { name: "Charlie", active: false }
];

const hasActive = users.some(u => u.active);
// true ✅ (есть хотя бы один активный)

// Проверка на наличие
const hasAdmin = users.some(u => u.role === "admin");
```

### `every` — проверяет, все ли соответствуют

`every` возвращает `true`, если **все элементы** соответствуют условию:

```js
const numbers = [2, 4, 6, 8];

numbers.every(n => n % 2 === 0);  // true ✅ (все чётные)
numbers.every(n => n > 5);        // false ✅ (не все > 5)
```

**Синтаксис:**
```js
array.every((element, index, array) => {
  // возвращает true/false
});
```

**Примеры:**
```js
const users = [
  { age: 25 },
  { age: 30 },
  { age: 28 }
];

const allAdults = users.every(u => u.age >= 18);
// true ✅ (всем есть 18+)

// Валидация формы
const fields = ["name", "email", "password"];
const allFilled = fields.every(field => form[field].length > 0);
```

### Сравнительная таблица

| Метод | Что возвращает | Когда возвращает `true` |
|-------|---------------|------------------------|
| `find` | Элемент или `undefined` | Когда находит первый подходящий |
| `some` | `true` или `false` | Когда хотя бы один подходит |
| `every` | `true` или `false` | Когда все подходят |

### Особенности

#### Пустой массив

```js
[].some(() => true);   // false ✅ (нет элементов для проверки)
[].every(() => true);  // true ✅ (все 0 элементов соответствуют!)
```

**Почему `every` возвращает `true` для пустого массива?** Это математическое правило: для пустого множества все элементы соответствуют любому условию (vacuous truth).

#### Прерывание выполнения

Все три метода **прерывают выполнение**, когда находят результат:

```js
const numbers = [1, 2, 3, 4, 5];

// some прервётся на первом true
numbers.some(n => {
  console.log(n);  // 1, 2 (прервалось на 2, т.к. 2 > 1)
  return n > 1;
});

// every прервётся на первом false
numbers.every(n => {
  console.log(n);  // 1 (прервалось на 1, т.к. 1 не > 1)
  return n > 1;
});
```

### Примеры использования

```js
const products = [
  { name: "Laptop", price: 1000, inStock: true },
  { name: "Phone", price: 500, inStock: false },
  { name: "Tablet", price: 300, inStock: true }
];

// Найти первый доступный товар
const available = products.find(p => p.inStock);
// { name: "Laptop", price: 1000, inStock: true }

// Проверить, есть ли дорогие товары (> 800)
const hasExpensive = products.some(p => p.price > 800);
// true

// Проверить, все ли товары доступны
const allAvailable = products.every(p => p.inStock);
// false
```

### Разница с `filter`

```js
const numbers = [1, 2, 3, 4, 5];

// find — первый элемент
numbers.find(n => n > 2);  // 3 ✅ (один элемент)

// filter — все подходящие элементы
numbers.filter(n => n > 2);  // [3, 4, 5] ✅ (массив)
```

### Итоги

- `find` — находит первый подходящий элемент (или `undefined`)
- `some` — проверяет, есть ли хотя бы один (`true`/`false`)
- `every` — проверяет, все ли подходят (`true`/`false`)
- Все три прерывают выполнение при нахождении результата
- `every` возвращает `true` для пустого массива

---

## 49. Мутирующие и немутирующие методы массивов

Важно знать, какие методы массивов изменяют исходный массив, а какие создают новый.

### Немутирующие методы (не изменяют исходный массив)

Эти методы **возвращают новый массив** или значение:

```js
const arr = [1, 2, 3];

arr.map(x => x * 2);        // [2, 4, 6] ✅ (новый массив)
arr.filter(x => x > 1);     // [2, 3] ✅ (новый массив)
arr.slice(0, 2);            // [1, 2] ✅ (новый массив)
arr.concat([4]);            // [1, 2, 3, 4] ✅ (новый массив)
arr.reduce((a, b) => a + b); // 6 ✅ (значение)

console.log(arr);  // [1, 2, 3] ✅ (не изменился)
```

**Список немутирующих методов:**
- `map` — преобразование
- `filter` — фильтрация
- `slice` — копирование части
- `concat` — объединение
- `reduce` / `reduceRight` — свёртка
- `find` / `findIndex` — поиск
- `some` / `every` — проверка
- `indexOf` / `lastIndexOf` — поиск индекса
- `includes` — проверка наличия
- `join` — объединение в строку

### Мутирующие методы (изменяют исходный массив)

Эти методы **изменяют исходный массив**:

```js
const arr = [1, 2, 3];

arr.push(4);        // [1, 2, 3, 4] ❌ (изменён)
arr.pop();          // [1, 2, 3] ❌ (изменён)
arr.unshift(0);     // [0, 1, 2, 3] ❌ (изменён)
arr.shift();        // [1, 2, 3] ❌ (изменён)
arr.sort();         // ❌ (изменён)
arr.reverse();      // ❌ (изменён)
arr.splice(1, 1);   // ❌ (изменён)

console.log(arr);  // изменён! ❌
```

**Список мутирующих методов:**
- `push` — добавить в конец
- `pop` — удалить с конца
- `unshift` — добавить в начало
- `shift` — удалить с начала
- `sort` — сортировка
- `reverse` — обратный порядок
- `splice` — удаление/вставка элементов
- `fill` — заполнение
- `copyWithin` — копирование внутри массива

### Как сделать мутирующие методы немутирующими?

#### 1. Создать копию перед изменением

```js
const arr = [3, 1, 2];

// sort — мутирует
arr.sort();  // ❌ изменяет arr

// Правильно — создать копию
const sorted = [...arr].sort();  // ✅ новый массив
console.log(arr);  // [3, 1, 2] (не изменился)
```

#### 2. Использовать альтернативы

```js
// push — мутирует
arr.push(4);  // ❌

// Альтернатива — concat или spread
const newArr = arr.concat(4);  // ✅
// или
const newArr = [...arr, 4];  // ✅

// reverse — мутирует
arr.reverse();  // ❌

// Альтернатива — создать копию
const reversed = [...arr].reverse();  // ✅
```

### ⚠️ Частая ошибка

Использование мутирующих методов, думая, что они немутирующие:

```js
const numbers = [3, 1, 2];

function getSorted(arr) {
  return arr.sort();  // ❌ мутирует исходный массив!
}

const sorted = getSorted(numbers);
console.log(numbers);  // [1, 2, 3] ⚠️ (изменился!)
```

**Правильно:**
```js
function getSorted(arr) {
  return [...arr].sort();  // ✅ создаёт копию
}
```

### Особый случай: `sort`

`sort` **всегда мутирует** массив:

```js
const arr = [3, 1, 2];
const sorted = arr.sort();

console.log(arr);    // [1, 2, 3] ❌ (изменился!)
console.log(sorted); // [1, 2, 3] (та же ссылка!)

// arr === sorted → true (один и тот же массив!)
```

**Правильно:**
```js
const sorted = [...arr].sort();  // ✅ копия
```

### Когда использовать мутирующие методы?

Мутирующие методы можно использовать, когда:
- Нужно изменить массив на месте (для производительности)
- Массив больше не используется после изменения
- Работа с большими массивами (экономия памяти)

Но в современном JavaScript обычно предпочитают иммутабельный подход.

### Сравнительная таблица

| Метод | Тип | Возвращает |
|-------|-----|-----------|
| `map`, `filter`, `slice` | Немутирующий | Новый массив |
| `push`, `pop`, `sort` | Мутирующий | Изменённый массив (та же ссылка) |
| `find`, `some`, `every` | Немутирующий | Значение/boolean |

### Итоги

- Немутирующие методы создают новый массив
- Мутирующие методы изменяют исходный массив
- Используйте spread `[...arr]` для копирования перед мутацией
- В современном коде предпочитают немутирующие методы

---

## 50. `Set`, `Map`, `WeakSet`, `WeakMap`

Это специальные коллекции в JavaScript для работы с данными. Каждая имеет свои особенности.

### `Set` — коллекция уникальных значений

`Set` хранит **только уникальные значения** (примитивы или ссылки на объекты):

```js
const set = new Set([1, 2, 2, 3, 3, 3]);
console.log(set);  // Set(3) {1, 2, 3} ✅ (дубликаты удалены)

set.add(4);
set.add(2);  // не добавится (уже есть)
console.log(set.size);  // 4
```

**Методы:**
```js
const set = new Set();

set.add(value);      // добавить
set.has(value);      // проверить наличие
set.delete(value);   // удалить
set.clear();         // очистить
set.size;            // размер (не length!)
```

**Примеры использования:**
```js
// Удаление дубликатов из массива
const arr = [1, 2, 2, 3, 3, 3];
const unique = [...new Set(arr)];  // [1, 2, 3] ✅

// Проверка уникальности
const emails = ["a@test.com", "b@test.com", "a@test.com"];
const uniqueEmails = new Set(emails);
if (emails.length !== uniqueEmails.size) {
  console.log("Есть дубликаты!");
}
```

### `Map` — коллекция пар ключ-значение

`Map` хранит пары **ключ-значение**, где ключом может быть **любой тип** (не только строка):

```js
const map = new Map();

map.set("name", "Alex");           // строка как ключ
map.set(1, "one");                 // число как ключ
map.set(true, "yes");              // boolean как ключ
map.set({ id: 1 }, "object key");  // объект как ключ! ✅

console.log(map.get("name"));      // "Alex"
console.log(map.get(1));           // "one"
```

**Методы:**
```js
const map = new Map();

map.set(key, value);  // установить
map.get(key);         // получить
map.has(key);         // проверить
map.delete(key);      // удалить
map.clear();          // очистить
map.size;             // размер
```

**Итерация:**
```js
const map = new Map([["a", 1], ["b", 2]]);

map.keys();      // итератор ключей
map.values();    // итератор значений
map.entries();   // итератор пар [key, value]

for (let [key, value] of map) {
  console.log(key, value);
}
```

### `WeakSet` — Set для объектов

`WeakSet` похож на `Set`, но:
- Хранит **только объекты** (не примитивы)
- **Не итерируемый** (нет методов для перебора)
- Не препятствует сборке мусора (weak references)

```js
const weakSet = new WeakSet();

const obj = { id: 1 };
weakSet.add(obj);
weakSet.has(obj);  // true
weakSet.delete(obj);

// Нет size, нет итерации!
```

**Использование:** для хранения "меток" объектов (например, обработанные объекты).

### `WeakMap` — Map для объектов как ключей

`WeakMap` похож на `Map`, но:
- Ключами могут быть **только объекты**
- **Не итерируемый**
- Не препятствует сборке мусора

```js
const weakMap = new WeakMap();

const key = { id: 1 };
weakMap.set(key, "value");
weakMap.get(key);  // "value"
weakMap.has(key);  // true

// Нет size, нет итерации!
```

**Использование:** приватные данные объектов, кэши, метаданные.

### Сравнительная таблица

| Коллекция | Ключи | Итерация | Weak references |
|-----------|-------|----------|----------------|
| `Set` | Любые | ✅ Да | ❌ Нет |
| `Map` | Любые | ✅ Да | ❌ Нет |
| `WeakSet` | Только объекты | ❌ Нет | ✅ Да |
| `WeakMap` | Только объекты | ❌ Нет | ✅ Да |

### Когда использовать что?

- **`Set`** — когда нужны уникальные значения
- **`Map`** — когда нужны ключи любого типа (не только строки)
- **`WeakSet`** — для меток объектов (редко)
- **`WeakMap`** — для приватных данных объектов, кэшей

### Пример: `Map` vs обычный объект

```js
// Обычный объект — ключи только строки
const obj = {};
obj[1] = "one";
obj["1"];  // "one" (1 преобразовано в "1")

// Map — ключи сохраняют тип
const map = new Map();
map.set(1, "one");
map.set("1", "one string");
map.get(1);     // "one"
map.get("1");   // "one string" ✅ (разные ключи!)
```

### Итоги

- `Set` — уникальные значения
- `Map` — пары ключ-значение, ключи любого типа
- `WeakSet` / `WeakMap` — только объекты, weak references
- `Set`/`Map` — итерируемые, `Weak*` — нет
- Используйте `Set` для уникальности, `Map` для ключей любого типа

---
