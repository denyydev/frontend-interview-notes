## JS CORE

1. Типы данных в JavaScript
2. Разница между `null` и `undefined`
3. Отличия `var`, `let` и `const`
4. Strict mode в JavaScript
5. Что такое hoisting
6. Разница между `function declaration` и `function expression`
7. Стрелочные функции
8. Что такое `this` и как он определяется
9. `call`, `apply`, `bind`
10. Что такое замыкание
11. Как передаются аргументы в функции JavaScript
12. Разница между `==` и `===`
13. Как проверить значение на `NaN`
14. Изменяемы ли строки в JavaScript
15. Что такое область видимости (scope)
16. Что такое прототип
17. Что находится в конце цепочки прототипов
18. Разница между поверхностным и глубоким копированием
19. Способы копирования объектов в JavaScript
20. Как сделать глубокую копию объекта
21. `map`, `filter`, `reduce`
22. Разница между `map` и `forEach`
23. `Set`, `Map`, `WeakSet`, `WeakMap`
24. IIFE (Immediately Invoked Function Expression)
25. Что такое Promise и какие у него состояния
26. Способы обработки ошибок в Promise
27. Что такое `async / await`
28. Что такое Event Loop и зачем он нужен

## 1. Типы данных в JavaScript

Кратко:  
В JavaScript есть **8 типов данных**.

Примитивные (7):  
`string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`

Ссылочный (1):  
`object` (объекты, массивы, функции)

---

Важно:

- Примитивы хранятся **по значению**
- Объекты — **по ссылке**
- `typeof null === 'object'` — историческая ошибка

---

Пример:

```js
let a = 10;
let b = a;
b = 20;

let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 2;

console.log(a); // 10
console.log(obj1.x); // 2
```

---

## 2. Разница между `null` и `undefined`

Кратко:  
`undefined` означает, что значение **не было присвоено**.  
`null` — это **явно заданное пустое значение**.

---

Важно:

- `undefined` — значение по умолчанию для переменных и параметров
- `null` присваивается разработчиком вручную
- оба считаются falsy
- `null == undefined` → `true`, но `null === undefined` → `false`

---

Пример:

```js
let a;
let b = null;

console.log(a); // undefined
console.log(b); // null
```

---

## 3. Отличия `var`, `let` и `const`

Кратко:  
`var` — устаревший способ объявления переменных.  
`let` и `const` — современные варианты с блочной областью видимости.

---

Важно:

- `var` имеет функциональную область видимости и поднимается (hoisting)
- `let` и `const` имеют блочную область видимости и находятся в TDZ
- `const` нельзя переопределить, но объект внутри можно изменить

---

Пример:

```js
if (true) {
  var a = 1;
  let b = 2;
  const c = 3;
}

console.log(a); // 1
console.log(b); // ReferenceError
console.log(c); // ReferenceError
```

## 4. Strict mode в JavaScript

Кратко:  
Strict mode — это режим, который делает JavaScript более строгим и помогает избегать ошибок.

---

Важно:

- запрещает использование не объявленных переменных
- меняет поведение `this` (в обычной функции будет `undefined`)
- запрещает дублирование параметров функции
- выбрасывает ошибки там, где раньше было “тихо”

---

Пример:

```js
"use strict";

x = 10; // ReferenceError
```

## 5. Что такое hoisting (всплытие)?

Кратко:  
Hoisting — это механизм, при котором объявления переменных и функций поднимаются в начало области видимости.

---

Важно:

- `var` поднимается и инициализируется как `undefined`
- `let` и `const` поднимаются, но недоступны до объявления (TDZ)
- `function declaration` доступна до объявления

---

Пример:

```js
console.log(a); // undefined
var a = 10;

console.log(b); // ReferenceError
let b = 20;

foo(); // работает
function foo() {
  console.log("ok");
}
```

## 6. Разница между `function declaration` и `function expression`

Кратко:  
`function declaration` — объявляется как отдельная инструкция и поднимается целиком.  
`function expression` — это функция, присвоенная переменной.

---

Важно:

- `function declaration` доступна до объявления
- `function expression` доступна только после инициализации
- `function expression` часто используется в колбэках

---

Пример:

```js
foo(); // работает
function foo() {}

bar(); // TypeError
const bar = function () {};
```

## 7. Стрелочные функции

Кратко:  
Стрелочные функции — это более короткий синтаксис функций, который **не имеет собственного `this`**.

---

Важно:

- `this` берётся из внешнего контекста
- нельзя использовать как конструктор (`new`)
- нет `arguments`
- удобны для колбэков

---

Пример:

```js
const obj = {
  value: 10,
  regular() {
    setTimeout(function () {
      console.log(this.value); // undefined
    }, 0);

    setTimeout(() => {
      console.log(this.value); // 10
    }, 0);
  },
};

obj.regular();
```

## 8. Что такое `this` и как он определяется

Кратко:  
`this` — это контекст выполнения функции. Его значение определяется **в момент вызова**, а не объявления.

---

Важно:

- в обычной функции зависит от способа вызова
- в методе объекта — ссылка на объект
- в стрелочной функции — берётся из внешнего контекста
- `call`, `apply`, `bind` могут явно задать `this`

---

Пример:

```js
const obj = {
  value: 5,
  show() {
    console.log(this.value);
  },
};

obj.show(); // 5

const fn = obj.show;
fn(); // undefined
```

## 9. `call`, `apply`, `bind`

Кратко:  
`call`, `apply` и `bind` используются для **явного задания `this`** и управления контекстом вызова функции.

---

Важно:

- `call(this, a, b)` — вызывает функцию сразу
- `apply(this, [a, b])` — вызывает функцию сразу, аргументы массивом
- `bind(this)` — **не вызывает функцию**, а возвращает новую с привязанным `this`
- `bind` часто используют для колбэков и обработчиков событий

---

Пример:

```js
function log(a, b) {
  console.log(this.value, a, b);
}

const obj = { value: 10 };

log.call(obj, 1, 2); // 10 1 2
log.apply(obj, [1, 2]); // 10 1 2

const boundLog = log.bind(obj);
boundLog(1, 2); // 10 1 2
```

## 10. Что такое замыкание

Кратко:  
Замыкание — это функция, которая имеет доступ к переменным из внешней области видимости даже после её выполнения.

---

Важно:

- переменные внешней функции не удаляются, пока есть ссылка
- часто используется для инкапсуляции и приватных данных
- может привести к утечкам памяти при неправильном использовании

---

Пример:

```js
function counter() {
  let count = 0;

  return function () {
    count++;
    return count;
  };
}

const inc = counter();

inc(); // 1
inc(); // 2
```

## 11. Как передаются аргументы в функции JavaScript

Кратко:  
В JavaScript аргументы передаются **по значению**, но для объектов передаётся **значение ссылки**.

---

Важно:

- примитивы копируются
- объекты и массивы передаются как ссылка
- изменение объекта внутри функции влияет на исходный объект

---

Пример:

```js
function changeValue(x) {
  x = 20;
}

function changeObj(obj) {
  obj.value = 20;
}

let a = 10;
let o = { value: 10 };

changeValue(a);
changeObj(o);

console.log(a); // 10
console.log(o.value); // 20
```

## 12. Разница между `==` и `===`

Кратко:  
`==` сравнивает значения с приведением типов.  
`===` сравнивает значения **без приведения типов**.

---

Важно:

- `==` может давать неожиданные результаты
- `===` сравнивает и тип, и значение
- в современном коде почти всегда используют `===`

---

Пример:

```js
0 == "0"; // true
0 === "0"; // false

null == undefined; // true
null === undefined; // false
```

## 13. Как проверить значение на `NaN`

Кратко:  
`NaN` — это специальное значение типа `number`.  
Правильный способ проверки — `Number.isNaN()`.

---

Важно:

- `NaN` не равен самому себе
- `isNaN()` приводит типы и может дать неверный результат
- `Number.isNaN()` не делает приведение типов

---

Пример:

```js
Number.isNaN(NaN); // true
Number.isNaN("abc"); // false

isNaN("abc"); // true (плохо)
NaN === NaN; // false
```

## 14. Изменяемы ли строки в JavaScript

Кратко:  
Строки в JavaScript **неизменяемы**. Любая операция со строкой создаёт новую строку.

---

Важно:

- нельзя изменить символ по индексу
- методы строк возвращают новую строку
- при “изменении” строки создаётся новое значение в памяти

---

Пример:

```js
let str = "hello";

str[0] = "H";
console.log(str); // 'hello'

str = str + "!";
console.log(str); // 'hello!'
```

## 15. Что такое область видимости (scope)

Кратко:  
Область видимости — это место в коде, где переменная доступна.

---

Важно:

- в JavaScript есть глобальная, функциональная и блочная область видимости
- `var` имеет функциональную область видимости
- `let` и `const` имеют блочную область видимости
- JavaScript использует лексическую область видимости

---

Пример:

```js
let a = 1;

function test() {
  let b = 2;

  if (true) {
    let c = 3;
    console.log(a, b, c); // 1 2 3
  }

  console.log(c); // ReferenceError
}

test();
```

## 16. Что такое прототип

Кратко:  
Прототип — это механизм, с помощью которого объекты в JavaScript наследуют свойства друг у друга.

---

Важно:

- у каждого объекта есть скрытое свойство `[[Prototype]]`
- доступ к прототипу можно получить через `__proto__`
- методы обычно хранятся в прототипе
- используется для наследования

---

Пример:

```js
function User(name) {
  this.name = name;
}

User.prototype.sayHi = function () {
  console.log(this.name);
};

const user = new User("Alex");
user.sayHi(); // Alex
```

## 17. Что находится в конце цепочки прототипов

Кратко:  
В конце цепочки прототипов находится `null`.

---

Важно:

- поиск свойства идёт вверх по цепочке прототипов
- если свойство не найдено, возвращается `undefined`
- `Object.prototype` — последний объект в цепочке
- его прототип равен `null`

---

Пример:

```js
const obj = {};

Object.getPrototypeOf(obj) === Object.prototype; // true
Object.getPrototypeOf(Object.prototype) === null; // true
```

## 18. Разница между поверхностным и глубоким копированием

Кратко:  
Поверхностное копирование копирует только первый уровень объекта.  
Глубокое копирование создаёт полностью независимую копию со всеми вложенными объектами.

---

Важно:

- при поверхностном копировании вложенные объекты передаются по ссылке
- при глубоком копировании изменения не затрагивают исходный объект
- глубокое копирование дороже по производительности

---

Пример:

```js
const original = { a: 1, b: { c: 2 } };

// поверхностная копия
const shallow = { ...original };
shallow.b.c = 3;

console.log(original.b.c); // 3

// глубокая копия
const deep = structuredClone(original);
deep.b.c = 4;

console.log(original.b.c); // 3
```

## 19. Способы копирования объектов в JavaScript

Кратко:  
В JavaScript есть несколько способов копирования объектов — поверхностные и глубокие.

---

Важно:

- поверхностное копирование: `Object.assign`, spread (`{ ...obj }`)
- глубокое копирование: `structuredClone`, `JSON.parse(JSON.stringify())`
- JSON-способ не копирует функции, `undefined`, `Symbol`, `Date`, `Map`, `Set`

---

Пример:

```js
const obj = { a: 1, b: { c: 2 } };

const copy1 = Object.assign({}, obj);
const copy2 = { ...obj };

const deepCopy = structuredClone(obj);
```

## 20. Как сделать глубокую копию объекта

Кратко:  
Глубокая копия — это копия объекта, в которой все вложенные объекты копируются независимо.

---

Важно:

- лучший современный способ — `structuredClone`
- `JSON.parse(JSON.stringify())` подходит только для простых данных
- ручная реализация сложна и редко нужна

---

Пример:

```js
const obj = { a: 1, b: { c: 2 } };

const copy = structuredClone(obj);
copy.b.c = 3;

console.log(obj.b.c); // 2
```

## 21. `map`, `filter`, `reduce`

Кратко:  
Это методы массива для работы с данными без мутаций исходного массива.

---

Важно:

- `map` — преобразует каждый элемент
- `filter` — отбирает элементы по условию
- `reduce` — сводит массив к одному значению
- возвращают новый массив (кроме `reduce`)

---

Пример:

```js
const nums = [1, 2, 3, 4];

const doubled = nums.map((n) => n * 2); // [2, 4, 6, 8]
const even = nums.filter((n) => n % 2 === 0); // [2, 4]
const sum = nums.reduce((acc, n) => acc + n, 0); // 10
```

## 22. Разница между `map` и `forEach`

Кратко:  
`map` используется для преобразования массива и возвращает новый массив.  
`forEach` используется для выполнения действий и ничего не возвращает.

---

Важно:

- `map` всегда возвращает новый массив
- `forEach` возвращает `undefined`
- `forEach` не подходит для цепочек преобразований

---

Пример:

```js
const arr = [1, 2, 3];

const mapped = arr.map((n) => n * 2);
const result = arr.forEach((n) => n * 2);

console.log(mapped); // [2, 4, 6]
console.log(result); // undefined
```

## 23. `Set`, `Map`, `WeakSet`, `WeakMap`

Кратко:  
Это коллекции для хранения данных, отличающиеся типами ключей и управлением памятью.

---

Важно:

- `Set` хранит уникальные значения
- `Map` хранит пары ключ–значение, где ключом может быть любой тип
- `WeakSet` и `WeakMap` хранят только объекты
- `Weak*` не мешают сборщику мусора

---

Пример:

```js
const set = new Set([1, 1, 2]);
console.log(set); // {1, 2}

const map = new Map();
map.set({ id: 1 }, "value");

const weakMap = new WeakMap();
weakMap.set({ id: 2 }, "data");
```

## 24. IIFE (Immediately Invoked Function Expression)

Кратко:  
IIFE — это функция, которая вызывается сразу после объявления.

---

Важно:

- создаёт собственную область видимости
- использовалась до `let` и `const` для изоляции переменных
- выполняется только один раз

---

Пример:

```js
(function () {
  const a = 10;
  console.log(a);
})();
```

## 25. Что такое Promise и какие у него состояния

Кратко:  
Promise — это объект, представляющий результат асинхронной операции, которая может завершиться успешно или с ошибкой.

---

Состояния Promise:

- `pending` — начальное состояние, операция ещё выполняется
- `fulfilled` — операция успешно завершена (`resolve`)
- `rejected` — операция завершилась ошибкой (`reject`)

---

Важно:

- Promise может перейти только из `pending` в `fulfilled` или `rejected`
- после смены состояния оно больше не меняется
- результат доступен через `then`, ошибка — через `catch`

---

Пример:

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("done");
  }, 1000);
});

promise
  .then((result) => console.log(result))
  .catch((error) => console.error(error));
```

## 26. Какими способами можно обработать ошибку в Promise

Кратко:  
Ошибки в Promise можно обрабатывать с помощью `.catch()` или `try / catch` при использовании `async / await`.

---

Важно:

- `.catch()` ловит ошибки в цепочке `then`
- `try / catch` работает только внутри `async` функции
- `finally()` выполняется в любом случае

---

Пример:

```js
// через catch
fetch("/api")
  .then((res) => res.json())
  .catch((err) => console.error(err))
  .finally(() => console.log("done"));

// через async / await
async function load() {
  try {
    const res = await fetch("/api");
  } catch (err) {
    console.error(err);
  }
}
```

## 27. Что такое `async / await`

Кратко:  
`async / await` — это синтаксический сахар над Promise, который позволяет писать асинхронный код как синхронный.

---

Важно:

- `async` функция всегда возвращает Promise
- `await` приостанавливает выполнение до завершения Promise
- ошибки обрабатываются через `try / catch`

---

Пример:

```js
async function load() {
  const res = await fetch("/api");
  const data = await res.json();
  return data;
}

load().then((data) => console.log(data));
```

## 28. Что такое Event Loop и зачем он нужен

Кратко:  
Event Loop — это механизм, который позволяет JavaScript выполнять асинхронный код, не блокируя основной поток.

---

Важно:

- JavaScript однопоточный
- Event Loop управляет очередями задач
- синхронный код выполняется первым
- асинхронные задачи попадают в очереди и выполняются позже

---

Пример:

```js
console.log(1);

setTimeout(() => {
  console.log(2);
}, 0);

console.log(3);

// 1 3 2
```
