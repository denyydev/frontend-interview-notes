## 1. Типы данных в JavaScript

Кратко:  
В JavaScript есть **8 типов данных**.

Примитивные (7):  
`string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`

Ссылочный (1):  
`object` (объекты, массивы, функции)

---

Важно:

- Примитивы хранятся **по значению**
- Объекты — **по ссылке**
- `typeof null === 'object'` — историческая ошибка

---

Пример:

```js
let a = 10;
let b = a;
b = 20;

let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 2;

console.log(a); // 10
console.log(obj1.x); // 2
```

---

## 2. Разница между `null` и `undefined`

Кратко:  
`undefined` означает, что значение **не было присвоено**.  
`null` — это **явно заданное пустое значение**.

---

Важно:

- `undefined` — значение по умолчанию для переменных и параметров
- `null` присваивается разработчиком вручную
- оба считаются falsy
- `null == undefined` → `true`, но `null === undefined` → `false`

---

Пример:

```js
let a;
let b = null;

console.log(a); // undefined
console.log(b); // null
```

---

## 3. Отличия `var`, `let` и `const`

Кратко:  
`var` — устаревший способ объявления переменных.  
`let` и `const` — современные варианты с блочной областью видимости.

---

Важно:

- `var` имеет функциональную область видимости и поднимается (hoisting)
- `let` и `const` имеют блочную область видимости и находятся в TDZ
- `const` нельзя переопределить, но объект внутри можно изменить

---

Пример:

```js
if (true) {
  var a = 1;
  let b = 2;
  const c = 3;
}

console.log(a); // 1
console.log(b); // ReferenceError
console.log(c); // ReferenceError
```

## 4. Strict mode в JavaScript

Кратко:  
Strict mode — это режим, который делает JavaScript более строгим и помогает избегать ошибок.

---

Важно:

- запрещает использование не объявленных переменных
- меняет поведение `this` (в обычной функции будет `undefined`)
- запрещает дублирование параметров функции
- выбрасывает ошибки там, где раньше было “тихо”

---

Пример:

```js
"use strict";

x = 10; // ReferenceError
```

## 5. Что такое hoisting (всплытие)?

Кратко:  
Hoisting — это механизм, при котором объявления переменных и функций поднимаются в начало области видимости.

---

Важно:

- `var` поднимается и инициализируется как `undefined`
- `let` и `const` поднимаются, но недоступны до объявления (TDZ)
- `function declaration` доступна до объявления

---

Пример:

```js
console.log(a); // undefined
var a = 10;

console.log(b); // ReferenceError
let b = 20;

foo(); // работает
function foo() {
  console.log("ok");
}
```

## 6. Разница между `function declaration` и `function expression`

Кратко:  
`function declaration` — объявляется как отдельная инструкция и поднимается целиком.  
`function expression` — это функция, присвоенная переменной.

---

Важно:

- `function declaration` доступна до объявления
- `function expression` доступна только после инициализации
- `function expression` часто используется в колбэках

---

Пример:

```js
foo(); // работает
function foo() {}

bar(); // TypeError
const bar = function () {};
```

## 7. Стрелочные функции

Кратко:  
Стрелочные функции — это более короткий синтаксис функций, который **не имеет собственного `this`**.

---

Важно:

- `this` берётся из внешнего контекста
- нельзя использовать как конструктор (`new`)
- нет `arguments`
- удобны для колбэков

---

Пример:

```js
const obj = {
  value: 10,
  regular() {
    setTimeout(function () {
      console.log(this.value); // undefined
    }, 0);

    setTimeout(() => {
      console.log(this.value); // 10
    }, 0);
  },
};

obj.regular();
```

## 8. Что такое `this` и как он определяется

Кратко:  
`this` — это контекст выполнения функции. Его значение определяется **в момент вызова**, а не объявления.

---

Важно:

- в обычной функции зависит от способа вызова
- в методе объекта — ссылка на объект
- в стрелочной функции — берётся из внешнего контекста
- `call`, `apply`, `bind` могут явно задать `this`

---

Пример:

```js
const obj = {
  value: 5,
  show() {
    console.log(this.value);
  },
};

obj.show(); // 5

const fn = obj.show;
fn(); // undefined
```

## 9. `call`, `apply`, `bind`

Кратко:  
`call`, `apply` и `bind` используются для **явного задания `this`** и управления контекстом вызова функции.

---

Важно:

- `call(this, a, b)` — вызывает функцию сразу
- `apply(this, [a, b])` — вызывает функцию сразу, аргументы массивом
- `bind(this)` — **не вызывает функцию**, а возвращает новую с привязанным `this`
- `bind` часто используют для колбэков и обработчиков событий

---

Пример:

```js
function log(a, b) {
  console.log(this.value, a, b);
}

const obj = { value: 10 };

log.call(obj, 1, 2); // 10 1 2
log.apply(obj, [1, 2]); // 10 1 2

const boundLog = log.bind(obj);
boundLog(1, 2); // 10 1 2
```

## 10. Что такое замыкание

Кратко:  
Замыкание — это функция, которая имеет доступ к переменным из внешней области видимости даже после её выполнения.

---

Важно:

- переменные внешней функции не удаляются, пока есть ссылка
- часто используется для инкапсуляции и приватных данных
- может привести к утечкам памяти при неправильном использовании

---

Пример:

```js
function counter() {
  let count = 0;

  return function () {
    count++;
    return count;
  };
}

const inc = counter();

inc(); // 1
inc(); // 2
```

## 11. Как передаются аргументы в функции JavaScript

Кратко:  
В JavaScript аргументы передаются **по значению**, но для объектов передаётся **значение ссылки**.

---

Важно:

- примитивы копируются
- объекты и массивы передаются как ссылка
- изменение объекта внутри функции влияет на исходный объект

---

Пример:

```js
function changeValue(x) {
  x = 20;
}

function changeObj(obj) {
  obj.value = 20;
}

let a = 10;
let o = { value: 10 };

changeValue(a);
changeObj(o);

console.log(a); // 10
console.log(o.value); // 20
```

## 12. Разница между `==` и `===`

Кратко:  
`==` сравнивает значения с приведением типов.  
`===` сравнивает значения **без приведения типов**.

---

Важно:

- `==` может давать неожиданные результаты
- `===` сравнивает и тип, и значение
- в современном коде почти всегда используют `===`

---

Пример:

```js
0 == "0"; // true
0 === "0"; // false

null == undefined; // true
null === undefined; // false
```

## 13. Как проверить значение на `NaN`

Кратко:  
`NaN` — это специальное значение типа `number`.  
Правильный способ проверки — `Number.isNaN()`.

---

Важно:

- `NaN` не равен самому себе
- `isNaN()` приводит типы и может дать неверный результат
- `Number.isNaN()` не делает приведение типов

---

Пример:

```js
Number.isNaN(NaN); // true
Number.isNaN("abc"); // false

isNaN("abc"); // true (плохо)
NaN === NaN; // false
```

## 14. Изменяемы ли строки в JavaScript

Кратко:  
Строки в JavaScript **неизменяемы**. Любая операция со строкой создаёт новую строку.

---

Важно:

- нельзя изменить символ по индексу
- методы строк возвращают новую строку
- при “изменении” строки создаётся новое значение в памяти

---

Пример:

```js
let str = "hello";

str[0] = "H";
console.log(str); // 'hello'

str = str + "!";
console.log(str); // 'hello!'
```

## 15. Что такое область видимости (scope)

Кратко:  
Область видимости — это место в коде, где переменная доступна.

---

Важно:

- в JavaScript есть глобальная, функциональная и блочная область видимости
- `var` имеет функциональную область видимости
- `let` и `const` имеют блочную область видимости
- JavaScript использует лексическую область видимости

---

Пример:

```js
let a = 1;

function test() {
  let b = 2;

  if (true) {
    let c = 3;
    console.log(a, b, c); // 1 2 3
  }

  console.log(c); // ReferenceError
}

test();
```

## 16. Что такое прототип

Кратко:  
Прототип — это механизм, с помощью которого объекты в JavaScript наследуют свойства друг у друга.

---

Важно:

- у каждого объекта есть скрытое свойство `[[Prototype]]`
- доступ к прототипу можно получить через `__proto__`
- методы обычно хранятся в прототипе
- используется для наследования

---

Пример:

```js
function User(name) {
  this.name = name;
}

User.prototype.sayHi = function () {
  console.log(this.name);
};

const user = new User("Alex");
user.sayHi(); // Alex
```

## 17. Что находится в конце цепочки прототипов

Кратко:  
В конце цепочки прототипов находится `null`.

---

Важно:

- поиск свойства идёт вверх по цепочке прототипов
- если свойство не найдено, возвращается `undefined`
- `Object.prototype` — последний объект в цепочке
- его прототип равен `null`

---

Пример:

```js
const obj = {};

Object.getPrototypeOf(obj) === Object.prototype; // true
Object.getPrototypeOf(Object.prototype) === null; // true
```

## 18. Разница между поверхностным и глубоким копированием

Кратко:  
Поверхностное копирование копирует только первый уровень объекта.  
Глубокое копирование создаёт полностью независимую копию со всеми вложенными объектами.

---

Важно:

- при поверхностном копировании вложенные объекты передаются по ссылке
- при глубоком копировании изменения не затрагивают исходный объект
- глубокое копирование дороже по производительности

---

Пример:

```js
const original = { a: 1, b: { c: 2 } };

// поверхностная копия
const shallow = { ...original };
shallow.b.c = 3;

console.log(original.b.c); // 3

// глубокая копия
const deep = structuredClone(original);
deep.b.c = 4;

console.log(original.b.c); // 3
```

## 19. Способы копирования объектов в JavaScript

Кратко:  
В JavaScript есть несколько способов копирования объектов — поверхностные и глубокие.

---

Важно:

- поверхностное копирование: `Object.assign`, spread (`{ ...obj }`)
- глубокое копирование: `structuredClone`, `JSON.parse(JSON.stringify())`
- JSON-способ не копирует функции, `undefined`, `Symbol`, `Date`, `Map`, `Set`

---

Пример:

```js
const obj = { a: 1, b: { c: 2 } };

const copy1 = Object.assign({}, obj);
const copy2 = { ...obj };

const deepCopy = structuredClone(obj);
```

## 20. Как сделать глубокую копию объекта

Кратко:  
Глубокая копия — это копия объекта, в которой все вложенные объекты копируются независимо.

---

Важно:

- лучший современный способ — `structuredClone`
- `JSON.parse(JSON.stringify())` подходит только для простых данных
- ручная реализация сложна и редко нужна

---

Пример:

```js
const obj = { a: 1, b: { c: 2 } };

const copy = structuredClone(obj);
copy.b.c = 3;

console.log(obj.b.c); // 2
```
