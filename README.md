## 1. Типы данных в JavaScript

Кратко:  
В JavaScript есть **8 типов данных**.

Примитивные (7):  
`string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`

Ссылочный (1):  
`object` (объекты, массивы, функции)

---

Важно:

- Примитивы хранятся **по значению**
- Объекты — **по ссылке**
- `typeof null === 'object'` — историческая ошибка

---

Пример:

```js
let a = 10;
let b = a;
b = 20;

let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 2;

console.log(a); // 10
console.log(obj1.x); // 2
```

---

## 2. Разница между `null` и `undefined`

Кратко:  
`undefined` означает, что значение **не было присвоено**.  
`null` — это **явно заданное пустое значение**.

---

Важно:

- `undefined` — значение по умолчанию для переменных и параметров
- `null` присваивается разработчиком вручную
- оба считаются falsy
- `null == undefined` → `true`, но `null === undefined` → `false`

---

Пример:

```js
let a;
let b = null;

console.log(a); // undefined
console.log(b); // null
```

---

## 3. Отличия `var`, `let` и `const`

Кратко:  
`var` — устаревший способ объявления переменных.  
`let` и `const` — современные варианты с блочной областью видимости.

---

Важно:

- `var` имеет функциональную область видимости и поднимается (hoisting)
- `let` и `const` имеют блочную область видимости и находятся в TDZ
- `const` нельзя переопределить, но объект внутри можно изменить

---

Пример:

```js
if (true) {
  var a = 1;
  let b = 2;
  const c = 3;
}

console.log(a); // 1
console.log(b); // ReferenceError
console.log(c); // ReferenceError
```

## 4. Strict mode в JavaScript

Кратко:  
Strict mode — это режим, который делает JavaScript более строгим и помогает избегать ошибок.

---

Важно:

- запрещает использование не объявленных переменных
- меняет поведение `this` (в обычной функции будет `undefined`)
- запрещает дублирование параметров функции
- выбрасывает ошибки там, где раньше было “тихо”

---

Пример:

```js
"use strict";

x = 10; // ReferenceError
```

## 5. Что такое hoisting (всплытие)?

Кратко:  
Hoisting — это механизм, при котором объявления переменных и функций поднимаются в начало области видимости.

---

Важно:

- `var` поднимается и инициализируется как `undefined`
- `let` и `const` поднимаются, но недоступны до объявления (TDZ)
- `function declaration` доступна до объявления

---

Пример:

```js
console.log(a); // undefined
var a = 10;

console.log(b); // ReferenceError
let b = 20;

foo(); // работает
function foo() {
  console.log("ok");
}
```

## 6. Разница между `function declaration` и `function expression`

Кратко:  
`function declaration` — объявляется как отдельная инструкция и поднимается целиком.  
`function expression` — это функция, присвоенная переменной.

---

Важно:

- `function declaration` доступна до объявления
- `function expression` доступна только после инициализации
- `function expression` часто используется в колбэках

---

Пример:

```js
foo(); // работает
function foo() {}

bar(); // TypeError
const bar = function () {};
```

## 7. Стрелочные функции

Кратко:  
Стрелочные функции — это более короткий синтаксис функций, который **не имеет собственного `this`**.

---

Важно:

- `this` берётся из внешнего контекста
- нельзя использовать как конструктор (`new`)
- нет `arguments`
- удобны для колбэков

---

Пример:

```js
const obj = {
  value: 10,
  regular() {
    setTimeout(function () {
      console.log(this.value); // undefined
    }, 0);

    setTimeout(() => {
      console.log(this.value); // 10
    }, 0);
  },
};

obj.regular();
```

## 8. Что такое `this` и как он определяется

Кратко:  
`this` — это контекст выполнения функции. Его значение определяется **в момент вызова**, а не объявления.

---

Важно:

- в обычной функции зависит от способа вызова
- в методе объекта — ссылка на объект
- в стрелочной функции — берётся из внешнего контекста
- `call`, `apply`, `bind` могут явно задать `this`

---

Пример:

```js
const obj = {
  value: 5,
  show() {
    console.log(this.value);
  },
};

obj.show(); // 5

const fn = obj.show;
fn(); // undefined
```

## 9. `call`, `apply`, `bind`

Кратко:  
`call`, `apply` и `bind` используются для **явного задания `this`** и управления контекстом вызова функции.

---

Важно:

- `call(this, a, b)` — вызывает функцию сразу
- `apply(this, [a, b])` — вызывает функцию сразу, аргументы массивом
- `bind(this)` — **не вызывает функцию**, а возвращает новую с привязанным `this`
- `bind` часто используют для колбэков и обработчиков событий

---

Пример:

```js
function log(a, b) {
  console.log(this.value, a, b);
}

const obj = { value: 10 };

log.call(obj, 1, 2); // 10 1 2
log.apply(obj, [1, 2]); // 10 1 2

const boundLog = log.bind(obj);
boundLog(1, 2); // 10 1 2
```

## 10. Что такое замыкание

Кратко:  
Замыкание — это функция, которая имеет доступ к переменным из внешней области видимости даже после её выполнения.

---

Важно:

- переменные внешней функции не удаляются, пока есть ссылка
- часто используется для инкапсуляции и приватных данных
- может привести к утечкам памяти при неправильном использовании

---

Пример:

```js
function counter() {
  let count = 0;

  return function () {
    count++;
    return count;
  };
}

const inc = counter();

inc(); // 1
inc(); // 2
```

## 11. Как передаются аргументы в функции JavaScript

Кратко:  
В JavaScript аргументы передаются **по значению**, но для объектов передаётся **значение ссылки**.

---

Важно:

- примитивы копируются
- объекты и массивы передаются как ссылка
- изменение объекта внутри функции влияет на исходный объект

---

Пример:

```js
function changeValue(x) {
  x = 20;
}

function changeObj(obj) {
  obj.value = 20;
}

let a = 10;
let o = { value: 10 };

changeValue(a);
changeObj(o);

console.log(a); // 10
console.log(o.value); // 20
```

## 12. Разница между `==` и `===`

Кратко:  
`==` сравнивает значения с приведением типов.  
`===` сравнивает значения **без приведения типов**.

---

Важно:

- `==` может давать неожиданные результаты
- `===` сравнивает и тип, и значение
- в современном коде почти всегда используют `===`

---

Пример:

```js
0 == "0"; // true
0 === "0"; // false

null == undefined; // true
null === undefined; // false
```
