# Жизненный цикл браузера

Процесс загрузки и отображения веб-страницы в браузере.  
Материал представлен в формате **вопрос–ответ**.

---

## Содержание (Table of Contents)

1. [Как браузер загружает страницу (в общих чертах)](#1-как-браузер-загружает-страницу-в-общих-чертах)

---

## 1. Как браузер загружает страницу (в общих чертах)

Загрузка страницы в браузере — это многоэтапный процесс, который включает DNS-запрос, установку TCP-соединения, загрузку HTML, парсинг, построение DOM, загрузку ресурсов и рендеринг.

### Простое определение

Браузер загружает страницу в несколько этапов: сначала находит сервер (DNS), затем устанавливает соединение, загружает HTML, парсит его, строит DOM, загружает CSS и JavaScript, и наконец отображает страницу на экране.

**Аналогия:** Загрузка страницы — как строительство дома:
1. Найти адрес (DNS)
2. Добраться до места (TCP соединение)
3. Получить чертёж (HTML)
4. Изучить чертёж (парсинг)
5. Построить каркас (DOM)
6. Добавить отделку (CSS)
7. Установить электричество (JavaScript)
8. Заселиться (отображение)

### Этапы загрузки страницы

#### 1. Парсинг URL

Когда пользователь вводит URL или кликает на ссылку, браузер анализирует адрес.

```
https://example.com/path?query=value#fragment
```

**Компоненты URL:**
- `https://` — протокол
- `example.com` — домен
- `/path` — путь
- `?query=value` — query параметры
- `#fragment` — якорь

**Что делает браузер:**
- Определяет протокол (HTTP/HTTPS)
- Извлекает домен
- Определяет путь и параметры

#### 2. DNS Lookup (поиск IP-адреса)

Браузеру нужно найти IP-адрес сервера по доменному имени.

```
example.com → 93.184.216.34
```

**Процесс DNS lookup:**

1. **Проверка кеша браузера**
   ```javascript
   // Браузер проверяет свой DNS-кеш
   // Если домен уже был запрошен, использует кеш
   ```

2. **Проверка кеша ОС**
   - Если не найдено в браузере, проверяется кеш операционной системы

3. **Запрос к DNS-серверу**
   - Обычно это DNS-сервер провайдера или публичный (8.8.8.8, 1.1.1.1)
   - DNS-сервер возвращает IP-адрес

**Визуализация:**
```
Браузер → DNS-кеш → ОС кеш → DNS-сервер → IP-адрес
```

**Время:** Обычно 20-120ms (если не в кеше)

#### 3. TCP Connection (установка соединения)

Браузер устанавливает TCP-соединение с сервером.

**Процесс (TCP Handshake):**

1. **SYN** — браузер отправляет запрос на соединение
2. **SYN-ACK** — сервер подтверждает запрос
3. **ACK** — браузер подтверждает получение

```
Браузер                Сервер
   |                      |
   |-------- SYN -------->|
   |                      |
   |<----- SYN-ACK -------|
   |                      |
   |-------- ACK -------->|
   |                      |
   |   Соединение установлено |
```

**Для HTTPS:** Дополнительно выполняется TLS Handshake (SSL/TLS).

**Время:** Обычно 50-200ms

#### 4. HTTP Request (отправка запроса)

Браузер отправляет HTTP-запрос на сервер.

```http
GET /index.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0...
Accept: text/html,application/xhtml+xml
Accept-Language: ru-RU,ru;q=0.9
```

**Что отправляется:**
- Метод запроса (GET, POST, и т.д.)
- Путь к ресурсу
- Заголовки (Host, User-Agent, Accept, и т.д.)
- Cookie (если есть)

**Время:** Зависит от размера запроса, обычно <10ms

#### 5. HTTP Response (получение ответа)

Сервер отправляет HTTP-ответ с HTML-кодом.

```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1234
Date: Mon, 01 Jan 2024 12:00:00 GMT

<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <h1>Hello World</h1>
  </body>
</html>
```

**Что получает браузер:**
- Статус-код (200, 404, 500, и т.д.)
- Заголовки (Content-Type, Content-Length, и т.д.)
- Тело ответа (HTML)

**Время:** Зависит от размера HTML и скорости сети, обычно 100-500ms

#### 6. Parsing HTML (парсинг HTML)

Браузер парсит полученный HTML и строит DOM (Document Object Model).

**Процесс парсинга:**

1. **Токенизация** — разбиение HTML на токены
   ```html
   <div>Hello</div>
   ```
   Токены: `<div>`, `Hello`, `</div>`

2. **Построение дерева** — создание DOM-дерева
   ```
   html
   └── head
   │   └── title
   └── body
       └── h1
   ```

3. **Обработка скриптов** — если встречается `<script>`, парсинг может приостановиться

**Особенности:**
- Парсинг происходит **инкрементально** (по мере получения данных)
- Браузер может начать рендеринг до полной загрузки HTML
- `<script>` блокируют парсинг (если нет `async`/`defer`)

**Время:** Обычно 10-50ms для простого HTML

#### 7. Building DOM Tree (построение DOM)

Браузер строит DOM-дерево из распарсенного HTML.

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <h1>Hello</h1>
    <p>World</p>
  </body>
</html>
```

**DOM-дерево:**
```
Document
└── html
    ├── head
    │   └── title
    │       └── "Example"
    └── body
        ├── h1
        │   └── "Hello"
        └── p
            └── "World"
```

**Что происходит:**
- Создаются узлы (nodes) для каждого элемента
- Устанавливаются связи родитель-потомок
- Добавляются атрибуты
- Формируется полное дерево документа

**Время:** Обычно <10ms

#### 8. Loading Resources (загрузка ресурсов)

Браузер обнаруживает ресурсы в HTML (CSS, JavaScript, изображения) и загружает их.

**Ресурсы в HTML:**

```html
<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="/styles.css">
    <script src="/script.js"></script>
  </head>
  <body>
    <img src="/image.jpg" alt="Image">
  </body>
</html>
```

**Процесс загрузки:**

1. **CSS файлы**
   - Браузер загружает CSS параллельно
   - Парсит CSS и строит CSSOM (CSS Object Model)
   - CSS блокирует рендеринг (если нет `media`)

2. **JavaScript файлы**
   - Браузер загружает JS файлы
   - Выполняет JavaScript
   - Может блокировать парсинг и рендеринг

3. **Изображения**
   - Загружаются асинхронно
   - Не блокируют рендеринг
   - Могут отображаться постепенно

**Приоритеты загрузки:**
- Высокий: CSS, критический JavaScript
- Средний: JavaScript, шрифты
- Низкий: Изображения, видео

**Время:** Зависит от количества и размера ресурсов, обычно 500ms-5s

#### 9. Building CSSOM (построение CSS Object Model)

Браузер парсит CSS и строит CSSOM.

```css
body {
  font-size: 16px;
  color: #333;
}

h1 {
  font-size: 24px;
  color: #000;
}
```

**CSSOM-дерево:**
```
StyleSheet
└── body
    ├── font-size: 16px
    └── color: #333
└── h1
    ├── font-size: 24px
    └── color: #000
```

**Особенности:**
- CSSOM строится параллельно с DOM
- CSS блокирует рендеринг (если нет `media="print"`)
- Каскад и специфичность применяются при построении

**Время:** Обычно 10-50ms

#### 10. Building Render Tree (построение дерева рендеринга)

Браузер объединяет DOM и CSSOM в Render Tree.

**Процесс:**

1. **Объединение** DOM и CSSOM
2. **Фильтрация** невидимых элементов (`display: none`, `script`, `meta`)
3. **Создание** дерева рендеринга

**Пример:**

```html
<div style="display: none;">Hidden</div>
<p>Visible</p>
```

**Render Tree:**
```
RenderTree
└── p
    └── "Visible"
```

**Элемент `div` не попадает в Render Tree**, так как `display: none`.

**Время:** Обычно <10ms

#### 11. Layout (Reflow) — расчёт позиций

Браузер рассчитывает позиции и размеры элементов.

**Процесс Layout:**

1. **Расчёт размеров** каждого элемента
2. **Расчёт позиций** относительно родителя
3. **Учёт** margin, padding, border
4. **Учёт** flexbox, grid, float

**Пример:**

```css
.container {
  width: 800px;
  display: flex;
}

.item {
  width: 200px;
  margin: 10px;
}
```

Браузер рассчитывает:
- Позицию `.container` (0, 0)
- Размер `.container` (800px)
- Позиции `.item` внутри контейнера
- Размеры каждого `.item` (200px + margin)

**Время:** Зависит от сложности layout, обычно 10-100ms

#### 12. Paint (отрисовка)

Браузер отрисовывает элементы на экране.

**Процесс Paint:**

1. **Создание слоёв** (layers) для элементов
2. **Отрисовка** каждого слоя
3. **Применение** стилей (цвета, тени, градиенты)

**Что отрисовывается:**
- Текст
- Фоны
- Границы
- Тени
- Градиенты

**Время:** Зависит от сложности стилей, обычно 10-50ms

#### 13. Composite (композиция)

Браузер объединяет слои в финальное изображение.

**Процесс Composite:**

1. **Объединение** всех слоёв
2. **Применение** трансформаций и opacity
3. **Отправка** на GPU для отображения

**Оптимизация:**
- Элементы с `transform` или `opacity` создают отдельные слои
- Эти слои можно анимировать без перерисовки

**Время:** Обычно <10ms

### Визуальная временная шкала

```
0ms    100ms   200ms   300ms   400ms   500ms   600ms   700ms   800ms
|-------|-------|-------|-------|-------|-------|-------|-------|
DNS     TCP     HTTP    Parse   DOM     CSS     Render  Paint   Display
Lookup  Conn    Req/Res HTML    Build   Load    Tree    Layer   Screen
```

**Общее время:** Обычно 500ms-3s для простой страницы

### Блокирующие ресурсы

Некоторые ресурсы блокируют рендеринг:

#### CSS блокирует рендеринг

```html
<link rel="stylesheet" href="styles.css">
<!-- Рендеринг заблокирован до загрузки CSS -->
```

**Почему:** Браузер не хочет показывать нестилизованную страницу (FOUC).

#### JavaScript блокирует парсинг

```html
<script src="script.js"></script>
<!-- Парсинг HTML заблокирован до выполнения JS -->
```

**Почему:** JavaScript может изменить DOM, поэтому нужно дождаться его выполнения.

**Решения:**
- `async` — загружается параллельно, выполняется асинхронно
- `defer` — загружается параллельно, выполняется после парсинга

```html
<script src="script.js" async></script>
<script src="script.js" defer></script>
```

### Оптимизация загрузки

#### 1. Минификация и сжатие

```javascript
// До минификации
function calculateTotal(items) {
  let total = 0;
  for (let i = 0; i < items.length; i++) {
    total += items[i].price;
  }
  return total;
}

// После минификации
function calculateTotal(a){let b=0;for(let i=0;i<a.length;i++)b+=a[i].price;return b}
```

**Преимущества:**
- Меньший размер файла
- Быстрее загрузка
- Меньше трафика

#### 2. Кеширование

```http
Cache-Control: max-age=3600
ETag: "abc123"
```

**Преимущества:**
- Ресурсы загружаются из кеша
- Не нужно делать повторные запросы
- Быстрее загрузка

#### 3. Lazy Loading

```html
<!-- Изображения загружаются только когда видны -->
<img src="image.jpg" loading="lazy" alt="Image">

<!-- JavaScript загружается только когда нужен -->
<script src="heavy.js" defer></script>
```

#### 4. Code Splitting

```javascript
// Загружается только когда нужен
const HeavyComponent = lazy(() => import('./HeavyComponent'));
```

### Визуальная аналогия

**Загрузка страницы — как приготовление пиццы:**

1. **DNS Lookup** — найти адрес пиццерии (домен → IP)
2. **TCP Connection** — позвонить в пиццерию (установить связь)
3. **HTTP Request** — сделать заказ (запросить HTML)
4. **HTTP Response** — получить рецепт (HTML)
5. **Parsing HTML** — прочитать рецепт (парсинг)
6. **Building DOM** — подготовить ингредиенты (DOM)
7. **Loading Resources** — купить дополнительные ингредиенты (CSS, JS, изображения)
8. **Building CSSOM** — подготовить специи (CSSOM)
9. **Render Tree** — выбрать нужные ингредиенты (Render Tree)
10. **Layout** — разложить ингредиенты на тесто (позиционирование)
11. **Paint** — намазать соус и сыр (отрисовка)
12. **Composite** — поставить в духовку и получить готовую пиццу (отображение)

### ⚠️ Частая ошибка

Думают, что браузер ждёт полной загрузки HTML перед началом парсинга:

```html
<!-- ❌ Неправильное понимание -->
<!-- Браузер ждёт весь HTML, потом парсит -->

<!-- ✅ Правильное понимание -->
<!-- Браузер парсит HTML инкрементально, по мере получения данных -->
```

**Реальность:** Браузер начинает парсить HTML сразу, как только получает первые байты. Это называется **progressive rendering**.

### Критический путь рендеринга (Critical Rendering Path)

Критический путь — это минимальные шаги, необходимые для отображения контента:

1. **HTML** → Парсинг → **DOM**
2. **CSS** → Парсинг → **CSSOM**
3. **DOM + CSSOM** → **Render Tree**
4. **Layout** → **Paint** → **Display**

**Оптимизация критического пути:**
- Минифицировать HTML, CSS, JS
- Убрать блокирующий JavaScript
- Использовать inline критический CSS
- Отложить некритический CSS

### Итоги

- Загрузка страницы — многоэтапный процесс
- Основные этапы: DNS → TCP → HTTP → Парсинг → DOM → CSSOM → Render Tree → Layout → Paint → Display
- Браузер парсит HTML инкрементально (progressive rendering)
- CSS блокирует рендеринг
- JavaScript блокирует парсинг (без async/defer)
- Ресурсы загружаются параллельно
- Оптимизация: минификация, кеширование, lazy loading, code splitting
- Критический путь рендеринга — минимальные шаги для отображения
- Общее время загрузки обычно 500ms-3s для простой страницы
